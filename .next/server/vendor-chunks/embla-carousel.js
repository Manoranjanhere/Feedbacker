"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel";
exports.ids = ["vendor-chunks/embla-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction isNumber(subject) {\n    return typeof subject === \"number\";\n}\nfunction isString(subject) {\n    return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n    return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n    return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n    return Math.abs(n);\n}\nfunction mathSign(n) {\n    return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n    return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n    if (valueB === 0 || valueA === 0) return 0;\n    if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n    const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n    return mathAbs(diff / valueB);\n}\nfunction arrayKeys(array) {\n    return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n    return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n    return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n    return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n, startAt = 0) {\n    return Array.from(Array(n), (_, i)=>startAt + i);\n}\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n    return [\n        objectA,\n        objectB\n    ].reduce((mergedObjects, currentObject)=>{\n        objectKeys(currentObject).forEach((key)=>{\n            const valueA = mergedObjects[key];\n            const valueB = currentObject[key];\n            const areObjects = isObject(valueA) && isObject(valueB);\n            mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n        });\n        return mergedObjects;\n    }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n    return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n    const predefined = {\n        start,\n        center,\n        end\n    };\n    function start() {\n        return 0;\n    }\n    function center(n) {\n        return end(n) / 2;\n    }\n    function end(n) {\n        return viewSize - n;\n    }\n    function measure(n, index) {\n        if (isString(align)) return predefined[align](n);\n        return align(viewSize, n, index);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction Axis(axis, direction) {\n    const scroll = axis === \"y\" ? \"y\" : \"x\";\n    const cross = axis === \"y\" ? \"x\" : \"y\";\n    const startEdge = getStartEdge();\n    const endEdge = getEndEdge();\n    function measureSize(nodeRect) {\n        const { width, height } = nodeRect;\n        return scroll === \"x\" ? width : height;\n    }\n    function getStartEdge() {\n        if (scroll === \"y\") return \"top\";\n        return direction === \"rtl\" ? \"right\" : \"left\";\n    }\n    function getEndEdge() {\n        if (scroll === \"y\") return \"bottom\";\n        return direction === \"rtl\" ? \"left\" : \"right\";\n    }\n    const self = {\n        scroll,\n        cross,\n        startEdge,\n        endEdge,\n        measureSize\n    };\n    return self;\n}\nfunction Limit(min = 0, max = 0) {\n    const length = mathAbs(min - max);\n    function reachedMin(n) {\n        return n < min;\n    }\n    function reachedMax(n) {\n        return n > max;\n    }\n    function reachedAny(n) {\n        return reachedMin(n) || reachedMax(n);\n    }\n    function constrain(n) {\n        if (!reachedAny(n)) return n;\n        return reachedMin(n) ? min : max;\n    }\n    function removeOffset(n) {\n        if (!length) return n;\n        return n - length * Math.ceil((n - max) / length);\n    }\n    const self = {\n        length,\n        max,\n        min,\n        constrain,\n        reachedAny,\n        reachedMax,\n        reachedMin,\n        removeOffset\n    };\n    return self;\n}\nfunction Counter(max, start, loop) {\n    const { constrain } = Limit(0, max);\n    const loopEnd = max + 1;\n    let counter = withinLimit(start);\n    function withinLimit(n) {\n        return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n    }\n    function get() {\n        return counter;\n    }\n    function set(n) {\n        counter = withinLimit(n);\n        return self;\n    }\n    function add(n) {\n        return clone().set(get() + n);\n    }\n    function clone() {\n        return Counter(max, get(), loop);\n    }\n    const self = {\n        get,\n        set,\n        add,\n        clone\n    };\n    return self;\n}\nfunction Direction(direction) {\n    const sign = direction === \"rtl\" ? -1 : 1;\n    function apply(n) {\n        return n * sign;\n    }\n    const self = {\n        apply\n    };\n    return self;\n}\nfunction EventStore() {\n    let listeners = [];\n    function add(node, type, handler, options = {\n        passive: true\n    }) {\n        let removeListener;\n        if (\"addEventListener\" in node) {\n            node.addEventListener(type, handler, options);\n            removeListener = ()=>node.removeEventListener(type, handler, options);\n        } else {\n            const legacyMediaQueryList = node;\n            legacyMediaQueryList.addListener(handler);\n            removeListener = ()=>legacyMediaQueryList.removeListener(handler);\n        }\n        listeners.push(removeListener);\n        return self;\n    }\n    function clear() {\n        listeners = listeners.filter((remove)=>remove());\n    }\n    const self = {\n        add,\n        clear\n    };\n    return self;\n}\nfunction DragHandler(axis, direction, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n    const { cross: crossAxis } = axis;\n    const focusNodes = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ];\n    const nonPassiveEvent = {\n        passive: false\n    };\n    const initEvents = EventStore();\n    const dragEvents = EventStore();\n    const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n    const snapForceBoost = {\n        mouse: 300,\n        touch: 400\n    };\n    const freeForceBoost = {\n        mouse: 500,\n        touch: 600\n    };\n    const baseSpeed = dragFree ? 43 : 25;\n    let isMoving = false;\n    let startScroll = 0;\n    let startCross = 0;\n    let pointerIsDown = false;\n    let preventScroll = false;\n    let preventClick = false;\n    let isMouse = false;\n    function init(emblaApi) {\n        if (!watchDrag) return;\n        function downIfAllowed(evt) {\n            if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n        }\n        const node = rootNode;\n        initEvents.add(node, \"dragstart\", (evt)=>evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", ()=>undefined, nonPassiveEvent).add(node, \"touchend\", ()=>undefined).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n    }\n    function destroy() {\n        initEvents.clear();\n        dragEvents.clear();\n    }\n    function addDragEvents() {\n        const node = isMouse ? ownerDocument : rootNode;\n        dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n    }\n    function isFocusNode(node) {\n        const nodeName = node.nodeName || \"\";\n        return focusNodes.includes(nodeName);\n    }\n    function forceBoost() {\n        const boost = dragFree ? freeForceBoost : snapForceBoost;\n        const type = isMouse ? \"mouse\" : \"touch\";\n        return boost[type];\n    }\n    function allowedForce(force, targetChanged) {\n        const next = index.add(mathSign(force) * -1);\n        const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n        if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n        if (skipSnaps && targetChanged) return baseForce * 0.5;\n        return scrollTarget.byIndex(next.get(), 0).distance;\n    }\n    function down(evt) {\n        const isMouseEvt = isMouseEvent(evt, ownerWindow);\n        isMouse = isMouseEvt;\n        if (isMouseEvt && evt.button !== 0) return;\n        if (isFocusNode(evt.target)) return;\n        preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n        isMoving = deltaAbs(target.get(), location.get()) >= 2;\n        pointerIsDown = true;\n        dragTracker.pointerDown(evt);\n        scrollBody.useFriction(0).useDuration(0);\n        target.set(location);\n        addDragEvents();\n        startScroll = dragTracker.readPoint(evt);\n        startCross = dragTracker.readPoint(evt, crossAxis);\n        eventHandler.emit(\"pointerDown\");\n    }\n    function move(evt) {\n        const lastScroll = dragTracker.readPoint(evt);\n        const lastCross = dragTracker.readPoint(evt, crossAxis);\n        const diffScroll = deltaAbs(lastScroll, startScroll);\n        const diffCross = deltaAbs(lastCross, startCross);\n        if (!preventScroll && !isMouse) {\n            if (!evt.cancelable) return up(evt);\n            preventScroll = diffScroll > diffCross;\n            if (!preventScroll) return up(evt);\n        }\n        const diff = dragTracker.pointerMove(evt);\n        if (diffScroll > dragThreshold) preventClick = true;\n        scrollBody.useFriction(0.3).useDuration(1);\n        animation.start();\n        target.add(direction.apply(diff));\n        evt.preventDefault();\n    }\n    function up(evt) {\n        const currentLocation = scrollTarget.byDistance(0, false);\n        const targetChanged = currentLocation.index !== index.get();\n        const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n        const force = allowedForce(direction.apply(rawForce), targetChanged);\n        const forceFactor = factorAbs(rawForce, force);\n        const speed = baseSpeed - 10 * forceFactor;\n        const friction = baseFriction + forceFactor / 50;\n        preventScroll = false;\n        pointerIsDown = false;\n        dragEvents.clear();\n        scrollBody.useDuration(speed).useFriction(friction);\n        scrollTo.distance(force, !dragFree);\n        isMouse = false;\n        eventHandler.emit(\"pointerUp\");\n    }\n    function click(evt) {\n        if (preventClick) {\n            evt.stopPropagation();\n            evt.preventDefault();\n        }\n    }\n    function pointerDown() {\n        return pointerIsDown;\n    }\n    const self = {\n        init,\n        pointerDown,\n        destroy\n    };\n    return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n    const logInterval = 170;\n    let startEvent;\n    let lastEvent;\n    function readTime(evt) {\n        return evt.timeStamp;\n    }\n    function readPoint(evt, evtAxis) {\n        const property = evtAxis || axis.scroll;\n        const coord = `client${property === \"x\" ? \"X\" : \"Y\"}`;\n        return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n    }\n    function pointerDown(evt) {\n        startEvent = evt;\n        lastEvent = evt;\n        return readPoint(evt);\n    }\n    function pointerMove(evt) {\n        const diff = readPoint(evt) - readPoint(lastEvent);\n        const expired = readTime(evt) - readTime(startEvent) > logInterval;\n        lastEvent = evt;\n        if (expired) startEvent = evt;\n        return diff;\n    }\n    function pointerUp(evt) {\n        if (!startEvent || !lastEvent) return 0;\n        const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n        const diffTime = readTime(evt) - readTime(startEvent);\n        const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n        const force = diffDrag / diffTime;\n        const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n        return isFlick ? force : 0;\n    }\n    const self = {\n        pointerDown,\n        pointerMove,\n        pointerUp,\n        readPoint\n    };\n    return self;\n}\nfunction NodeRects() {\n    function measure(node) {\n        const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node;\n        const offset = {\n            top: offsetTop,\n            right: offsetLeft + offsetWidth,\n            bottom: offsetTop + offsetHeight,\n            left: offsetLeft,\n            width: offsetWidth,\n            height: offsetHeight\n        };\n        return offset;\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction PercentOfView(viewSize) {\n    function measure(n) {\n        return viewSize * (n / 100);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n    let resizeObserver;\n    let containerSize;\n    let slideSizes = [];\n    let destroyed = false;\n    function readSize(node) {\n        return axis.measureSize(nodeRects.measure(node));\n    }\n    function init(emblaApi) {\n        if (!watchResize) return;\n        containerSize = readSize(container);\n        slideSizes = slides.map(readSize);\n        function defaultCallback(entries) {\n            for (const entry of entries){\n                const isContainer = entry.target === container;\n                const slideIndex = slides.indexOf(entry.target);\n                const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n                const newSize = readSize(isContainer ? container : slides[slideIndex]);\n                const diffSize = mathAbs(newSize - lastSize);\n                if (diffSize >= 0.5) {\n                    ownerWindow.requestAnimationFrame(()=>{\n                        emblaApi.reInit();\n                        eventHandler.emit(\"resize\");\n                    });\n                    break;\n                }\n            }\n        }\n        resizeObserver = new ResizeObserver((entries)=>{\n            if (destroyed) return;\n            if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n                defaultCallback(entries);\n            }\n        });\n        const observeNodes = [\n            container\n        ].concat(slides);\n        observeNodes.forEach((node)=>resizeObserver.observe(node));\n    }\n    function destroy() {\n        if (resizeObserver) resizeObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction ScrollBody(location, offsetLocation, target, baseDuration, baseFriction) {\n    let bodyVelocity = 0;\n    let scrollDirection = 0;\n    let scrollDuration = baseDuration;\n    let scrollFriction = baseFriction;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    function seek() {\n        const diff = target.get() - location.get();\n        const isInstant = !scrollDuration;\n        let directionDiff = 0;\n        if (isInstant) {\n            bodyVelocity = 0;\n            location.set(target);\n            directionDiff = diff;\n        } else {\n            bodyVelocity += diff / scrollDuration;\n            bodyVelocity *= scrollFriction;\n            rawLocation += bodyVelocity;\n            location.add(bodyVelocity);\n            directionDiff = rawLocation - rawLocationPrevious;\n        }\n        scrollDirection = mathSign(directionDiff);\n        rawLocationPrevious = rawLocation;\n        return self;\n    }\n    function settled() {\n        const diff = target.get() - offsetLocation.get();\n        return mathAbs(diff) < 0.001;\n    }\n    function duration() {\n        return scrollDuration;\n    }\n    function direction() {\n        return scrollDirection;\n    }\n    function velocity() {\n        return bodyVelocity;\n    }\n    function useBaseDuration() {\n        return useDuration(baseDuration);\n    }\n    function useBaseFriction() {\n        return useFriction(baseFriction);\n    }\n    function useDuration(n) {\n        scrollDuration = n;\n        return self;\n    }\n    function useFriction(n) {\n        scrollFriction = n;\n        return self;\n    }\n    const self = {\n        direction,\n        duration,\n        velocity,\n        seek,\n        settled,\n        useBaseFriction,\n        useBaseDuration,\n        useFriction,\n        useDuration\n    };\n    return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n    const pullBackThreshold = percentOfView.measure(10);\n    const edgeOffsetTolerance = percentOfView.measure(50);\n    const frictionLimit = Limit(0.1, 0.99);\n    let disabled = false;\n    function shouldConstrain() {\n        if (disabled) return false;\n        if (!limit.reachedAny(target.get())) return false;\n        if (!limit.reachedAny(location.get())) return false;\n        return true;\n    }\n    function constrain(pointerDown) {\n        if (!shouldConstrain()) return;\n        const edge = limit.reachedMin(location.get()) ? \"min\" : \"max\";\n        const diffToEdge = mathAbs(limit[edge] - location.get());\n        const diffToTarget = target.get() - location.get();\n        const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n        target.subtract(diffToTarget * friction);\n        if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n            target.set(limit.constrain(target.get()));\n            scrollBody.useDuration(25).useBaseFriction();\n        }\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    const self = {\n        constrain,\n        toggleActive\n    };\n    return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n    const scrollBounds = Limit(-contentSize + viewSize, 0);\n    const snapsBounded = measureBounded();\n    const scrollContainLimit = findScrollContainLimit();\n    const snapsContained = measureContained();\n    function findScrollContainLimit() {\n        const startSnap = snapsBounded[0];\n        const endSnap = arrayLast(snapsBounded);\n        const min = snapsBounded.lastIndexOf(startSnap);\n        const max = snapsBounded.indexOf(endSnap) + 1;\n        return Limit(min, max);\n    }\n    function measureBounded() {\n        return snapsAligned.map((snapAligned, index)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(snapsAligned, index);\n            if (isFirst) return scrollBounds.max;\n            if (isLast) return scrollBounds.min;\n            return scrollBounds.constrain(snapAligned);\n        }).map((scrollBound)=>parseFloat(scrollBound.toFixed(3)));\n    }\n    function measureContained() {\n        if (contentSize <= viewSize + pixelTolerance) return [\n            scrollBounds.max\n        ];\n        if (containScroll === \"keepSnaps\") return snapsBounded;\n        const { min, max } = scrollContainLimit;\n        return snapsBounded.slice(min, max);\n    }\n    const self = {\n        snapsContained,\n        scrollContainLimit\n    };\n    return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n    const max = scrollSnaps[0];\n    const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n    const limit = Limit(min, max);\n    const self = {\n        limit\n    };\n    return self;\n}\nfunction ScrollLooper(contentSize, limit, offsetLocation, vectors) {\n    const jointSafety = 0.1;\n    const min = limit.min + jointSafety;\n    const max = limit.max + jointSafety;\n    const { reachedMin, reachedMax } = Limit(min, max);\n    function shouldLoop(direction) {\n        if (direction === 1) return reachedMax(offsetLocation.get());\n        if (direction === -1) return reachedMin(offsetLocation.get());\n        return false;\n    }\n    function loop(direction) {\n        if (!shouldLoop(direction)) return;\n        const loopDistance = contentSize * (direction * -1);\n        vectors.forEach((v)=>v.add(loopDistance));\n    }\n    const self = {\n        loop\n    };\n    return self;\n}\nfunction ScrollProgress(limit) {\n    const { max, length } = limit;\n    function get(n) {\n        const currentLocation = n - max;\n        return length ? currentLocation / -length : 0;\n    }\n    const self = {\n        get\n    };\n    return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n    const { startEdge, endEdge } = axis;\n    const { groupSlides } = slidesToScroll;\n    const alignments = measureSizes().map(alignment.measure);\n    const snaps = measureUnaligned();\n    const snapsAligned = measureAligned();\n    function measureSizes() {\n        return groupSlides(slideRects).map((rects)=>arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n    }\n    function measureUnaligned() {\n        return slideRects.map((rect)=>containerRect[startEdge] - rect[startEdge]).map((snap)=>-mathAbs(snap));\n    }\n    function measureAligned() {\n        return groupSlides(snaps).map((g)=>g[0]).map((snap, index)=>snap + alignments[index]);\n    }\n    const self = {\n        snaps,\n        snapsAligned\n    };\n    return self;\n}\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n    const { groupSlides } = slidesToScroll;\n    const { min, max } = scrollContainLimit;\n    const slideRegistry = createSlideRegistry();\n    function createSlideRegistry() {\n        const groupedSlideIndexes = groupSlides(slideIndexes);\n        const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n        if (scrollSnaps.length === 1) return [\n            slideIndexes\n        ];\n        if (doNotContain) return groupedSlideIndexes;\n        return groupedSlideIndexes.slice(min, max).map((group, index, groups)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(groups, index);\n            if (isFirst) {\n                const range = arrayLast(groups[0]) + 1;\n                return arrayFromNumber(range);\n            }\n            if (isLast) {\n                const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n                return arrayFromNumber(range, arrayLast(groups)[0]);\n            }\n            return group;\n        });\n    }\n    const self = {\n        slideRegistry\n    };\n    return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n    const { reachedAny, removeOffset, constrain } = limit;\n    function minDistance(distances) {\n        return distances.concat().sort((a, b)=>mathAbs(a) - mathAbs(b))[0];\n    }\n    function findTargetSnap(target) {\n        const distance = loop ? removeOffset(target) : constrain(target);\n        const ascDiffsToSnaps = scrollSnaps.map((scrollSnap)=>scrollSnap - distance).map((diffToSnap)=>shortcut(diffToSnap, 0)).map((diff, i)=>({\n                diff,\n                index: i\n            })).sort((d1, d2)=>mathAbs(d1.diff) - mathAbs(d2.diff));\n        const { index } = ascDiffsToSnaps[0];\n        return {\n            index,\n            distance\n        };\n    }\n    function shortcut(target, direction) {\n        const targets = [\n            target,\n            target + contentSize,\n            target - contentSize\n        ];\n        if (!loop) return targets[0];\n        if (!direction) return minDistance(targets);\n        const matchingTargets = targets.filter((t)=>mathSign(t) === direction);\n        if (matchingTargets.length) return minDistance(matchingTargets);\n        return arrayLast(targets) - contentSize;\n    }\n    function byIndex(index, direction) {\n        const diffToSnap = scrollSnaps[index] - targetVector.get();\n        const distance = shortcut(diffToSnap, direction);\n        return {\n            index,\n            distance\n        };\n    }\n    function byDistance(distance, snap) {\n        const target = targetVector.get() + distance;\n        const { index, distance: targetSnapDistance } = findTargetSnap(target);\n        const reachedBound = !loop && reachedAny(target);\n        if (!snap || reachedBound) return {\n            index,\n            distance\n        };\n        const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n        const snapDistance = distance + shortcut(diffToSnap, 0);\n        return {\n            index,\n            distance: snapDistance\n        };\n    }\n    const self = {\n        byDistance,\n        byIndex,\n        shortcut\n    };\n    return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollTarget, targetVector, eventHandler) {\n    function scrollTo(target) {\n        const distanceDiff = target.distance;\n        const indexDiff = target.index !== indexCurrent.get();\n        targetVector.add(distanceDiff);\n        if (distanceDiff) animation.start();\n        if (indexDiff) {\n            indexPrevious.set(indexCurrent.get());\n            indexCurrent.set(target.index);\n            eventHandler.emit(\"select\");\n        }\n    }\n    function distance(n, snap) {\n        const target = scrollTarget.byDistance(n, snap);\n        scrollTo(target);\n    }\n    function index(n, direction) {\n        const targetIndex = indexCurrent.clone().set(n);\n        const target = scrollTarget.byIndex(targetIndex.get(), direction);\n        scrollTo(target);\n    }\n    const self = {\n        distance,\n        index\n    };\n    return self;\n}\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore) {\n    let lastTabPressTime = 0;\n    function init() {\n        eventStore.add(document, \"keydown\", registerTabPress, false);\n        slides.forEach(addSlideFocusEvent);\n    }\n    function registerTabPress(event) {\n        if (event.code === \"Tab\") lastTabPressTime = new Date().getTime();\n    }\n    function addSlideFocusEvent(slide) {\n        const focus = ()=>{\n            const nowTime = new Date().getTime();\n            const diffTime = nowTime - lastTabPressTime;\n            if (diffTime > 10) return;\n            root.scrollLeft = 0;\n            const index = slides.indexOf(slide);\n            const group = slideRegistry.findIndex((group)=>group.includes(index));\n            if (!isNumber(group)) return;\n            scrollBody.useDuration(0);\n            scrollTo.index(group, 0);\n        };\n        eventStore.add(slide, \"focus\", focus, {\n            passive: true,\n            capture: true\n        });\n    }\n    const self = {\n        init\n    };\n    return self;\n}\nfunction Vector1D(initialValue) {\n    let value = initialValue;\n    function get() {\n        return value;\n    }\n    function set(n) {\n        value = normalizeInput(n);\n    }\n    function add(n) {\n        value += normalizeInput(n);\n    }\n    function subtract(n) {\n        value -= normalizeInput(n);\n    }\n    function normalizeInput(n) {\n        return isNumber(n) ? n : n.get();\n    }\n    const self = {\n        get,\n        set,\n        add,\n        subtract\n    };\n    return self;\n}\nfunction Translate(axis, direction, container) {\n    const translate = axis.scroll === \"x\" ? x : y;\n    const containerStyle = container.style;\n    let disabled = false;\n    function x(n) {\n        return `translate3d(${n}px,0px,0px)`;\n    }\n    function y(n) {\n        return `translate3d(0px,${n}px,0px)`;\n    }\n    function to(target) {\n        if (disabled) return;\n        containerStyle.transform = translate(direction.apply(target));\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    function clear() {\n        if (disabled) return;\n        containerStyle.transform = \"\";\n        if (!container.getAttribute(\"style\")) container.removeAttribute(\"style\");\n    }\n    const self = {\n        clear,\n        to,\n        toggleActive\n    };\n    return self;\n}\nfunction SlideLooper(axis, direction, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides) {\n    const roundingSafety = 0.5;\n    const ascItems = arrayKeys(slideSizesWithGaps);\n    const descItems = arrayKeys(slideSizesWithGaps).reverse();\n    const loopPoints = startPoints().concat(endPoints());\n    function removeSlideSizes(indexes, from) {\n        return indexes.reduce((a, i)=>{\n            return a - slideSizesWithGaps[i];\n        }, from);\n    }\n    function slidesInGap(indexes, gap) {\n        return indexes.reduce((a, i)=>{\n            const remainingGap = removeSlideSizes(a, gap);\n            return remainingGap > 0 ? a.concat([\n                i\n            ]) : a;\n        }, []);\n    }\n    function findSlideBounds(offset) {\n        return snaps.map((snap, index)=>({\n                start: snap - slideSizes[index] + roundingSafety + offset,\n                end: snap + viewSize - roundingSafety + offset\n            }));\n    }\n    function findLoopPoints(indexes, offset, isEndEdge) {\n        const slideBounds = findSlideBounds(offset);\n        return indexes.map((index)=>{\n            const initial = isEndEdge ? 0 : -contentSize;\n            const altered = isEndEdge ? contentSize : 0;\n            const boundEdge = isEndEdge ? \"end\" : \"start\";\n            const loopPoint = slideBounds[index][boundEdge];\n            return {\n                index,\n                loopPoint,\n                slideLocation: Vector1D(-1),\n                translate: Translate(axis, direction, slides[index]),\n                target: ()=>offsetLocation.get() > loopPoint ? initial : altered\n            };\n        });\n    }\n    function startPoints() {\n        const gap = scrollSnaps[0];\n        const indexes = slidesInGap(descItems, gap);\n        return findLoopPoints(indexes, contentSize, false);\n    }\n    function endPoints() {\n        const gap = viewSize - scrollSnaps[0] - 1;\n        const indexes = slidesInGap(ascItems, gap);\n        return findLoopPoints(indexes, -contentSize, true);\n    }\n    function canLoop() {\n        return loopPoints.every(({ index })=>{\n            const otherIndexes = ascItems.filter((i)=>i !== index);\n            return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n        });\n    }\n    function loop() {\n        loopPoints.forEach((loopPoint)=>{\n            const { target, translate, slideLocation } = loopPoint;\n            const shiftLocation = target();\n            if (shiftLocation === slideLocation.get()) return;\n            translate.to(shiftLocation);\n            slideLocation.set(shiftLocation);\n        });\n    }\n    function clear() {\n        loopPoints.forEach((loopPoint)=>loopPoint.translate.clear());\n    }\n    const self = {\n        canLoop,\n        clear,\n        loop,\n        loopPoints\n    };\n    return self;\n}\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n    let mutationObserver;\n    let destroyed = false;\n    function init(emblaApi) {\n        if (!watchSlides) return;\n        function defaultCallback(mutations) {\n            for (const mutation of mutations){\n                if (mutation.type === \"childList\") {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"slidesChanged\");\n                    break;\n                }\n            }\n        }\n        mutationObserver = new MutationObserver((mutations)=>{\n            if (destroyed) return;\n            if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n                defaultCallback(mutations);\n            }\n        });\n        mutationObserver.observe(container, {\n            childList: true\n        });\n    }\n    function destroy() {\n        if (mutationObserver) mutationObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n    const intersectionEntryMap = {};\n    let inViewCache = null;\n    let notInViewCache = null;\n    let intersectionObserver;\n    let destroyed = false;\n    function init() {\n        intersectionObserver = new IntersectionObserver((entries)=>{\n            if (destroyed) return;\n            entries.forEach((entry)=>{\n                const index = slides.indexOf(entry.target);\n                intersectionEntryMap[index] = entry;\n            });\n            inViewCache = null;\n            notInViewCache = null;\n            eventHandler.emit(\"slidesInView\");\n        }, {\n            root: container.parentElement,\n            threshold\n        });\n        slides.forEach((slide)=>intersectionObserver.observe(slide));\n    }\n    function destroy() {\n        if (intersectionObserver) intersectionObserver.disconnect();\n        destroyed = true;\n    }\n    function createInViewList(inView) {\n        return objectKeys(intersectionEntryMap).reduce((list, slideIndex)=>{\n            const index = parseInt(slideIndex);\n            const { isIntersecting } = intersectionEntryMap[index];\n            const inViewMatch = inView && isIntersecting;\n            const notInViewMatch = !inView && !isIntersecting;\n            if (inViewMatch || notInViewMatch) list.push(index);\n            return list;\n        }, []);\n    }\n    function get(inView = true) {\n        if (inView && inViewCache) return inViewCache;\n        if (!inView && notInViewCache) return notInViewCache;\n        const slideIndexes = createInViewList(inView);\n        if (inView) inViewCache = slideIndexes;\n        if (!inView) notInViewCache = slideIndexes;\n        return slideIndexes;\n    }\n    const self = {\n        init,\n        destroy,\n        get\n    };\n    return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n    const { measureSize, startEdge, endEdge } = axis;\n    const withEdgeGap = slideRects[0] && readEdgeGap;\n    const startGap = measureStartGap();\n    const endGap = measureEndGap();\n    const slideSizes = slideRects.map(measureSize);\n    const slideSizesWithGaps = measureWithGaps();\n    function measureStartGap() {\n        if (!withEdgeGap) return 0;\n        const slideRect = slideRects[0];\n        return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n    }\n    function measureEndGap() {\n        if (!withEdgeGap) return 0;\n        const style = ownerWindow.getComputedStyle(arrayLast(slides));\n        return parseFloat(style.getPropertyValue(`margin-${endEdge}`));\n    }\n    function measureWithGaps() {\n        return slideRects.map((rect, index, rects)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(rects, index);\n            if (isFirst) return slideSizes[index] + startGap;\n            if (isLast) return slideSizes[index] + endGap;\n            return rects[index + 1][startEdge] - rect[startEdge];\n        }).map(mathAbs);\n    }\n    const self = {\n        slideSizes,\n        slideSizesWithGaps,\n        startGap,\n        endGap\n    };\n    return self;\n}\nfunction SlidesToScroll(axis, direction, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n    const { startEdge, endEdge } = axis;\n    const groupByNumber = isNumber(slidesToScroll);\n    function byNumber(array, groupSize) {\n        return arrayKeys(array).filter((i)=>i % groupSize === 0).map((i)=>array.slice(i, i + groupSize));\n    }\n    function bySize(array) {\n        if (!array.length) return [];\n        return arrayKeys(array).reduce((groups, rectB)=>{\n            const rectA = arrayLast(groups) || 0;\n            const isFirst = rectA === 0;\n            const isLast = rectB === arrayLastIndex(array);\n            const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n            const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n            const gapA = !loop && isFirst ? direction.apply(startGap) : 0;\n            const gapB = !loop && isLast ? direction.apply(endGap) : 0;\n            const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n            if (chunkSize > viewSize + pixelTolerance) groups.push(rectB);\n            if (isLast) groups.push(array.length);\n            return groups;\n        }, []).map((currentSize, index, groups)=>{\n            const previousSize = Math.max(groups[index - 1] || 0);\n            return array.slice(previousSize, currentSize);\n        });\n    }\n    function groupSlides(array) {\n        return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n    }\n    const self = {\n        groupSlides\n    };\n    return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler, animations) {\n    // Options\n    const { align, axis: scrollAxis, direction: contentDirection, startIndex, loop, duration, dragFree, dragThreshold, inViewThreshold, slidesToScroll: groupSlides, skipSnaps, containScroll, watchResize, watchSlides, watchDrag } = options;\n    // Measurements\n    const pixelTolerance = 2;\n    const nodeRects = NodeRects();\n    const containerRect = nodeRects.measure(container);\n    const slideRects = slides.map(nodeRects.measure);\n    const direction = Direction(contentDirection);\n    const axis = Axis(scrollAxis, contentDirection);\n    const viewSize = axis.measureSize(containerRect);\n    const percentOfView = PercentOfView(viewSize);\n    const alignment = Alignment(align, viewSize);\n    const containSnaps = !loop && !!containScroll;\n    const readEdgeGap = loop || !!containScroll;\n    const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n    const slidesToScroll = SlidesToScroll(axis, direction, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n    const { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n    const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n    const { snapsContained, scrollContainLimit } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n    const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n    const { limit } = ScrollLimit(contentSize, scrollSnaps, loop);\n    // Indexes\n    const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n    const indexPrevious = index.clone();\n    const slideIndexes = arrayKeys(slides);\n    // Animation\n    const update = ({ dragHandler, scrollBody, scrollBounds, options: { loop } })=>{\n        if (!loop) scrollBounds.constrain(dragHandler.pointerDown());\n        scrollBody.seek();\n    };\n    const render = ({ scrollBody, translate, location, offsetLocation, scrollLooper, slideLooper, dragHandler, animation, eventHandler, options: { loop } }, lagOffset)=>{\n        const velocity = scrollBody.velocity();\n        const hasSettled = scrollBody.settled();\n        if (hasSettled && !dragHandler.pointerDown()) {\n            animation.stop();\n            eventHandler.emit(\"settle\");\n        }\n        if (!hasSettled) eventHandler.emit(\"scroll\");\n        offsetLocation.set(location.get() - velocity + velocity * lagOffset);\n        if (loop) {\n            scrollLooper.loop(scrollBody.direction());\n            slideLooper.loop();\n        }\n        translate.to(offsetLocation.get());\n    };\n    const animation = {\n        start: ()=>animations.start(engine),\n        stop: ()=>animations.stop(engine),\n        update: ()=>update(engine),\n        render: (lagOffset)=>render(engine, lagOffset)\n    };\n    // Shared\n    const friction = 0.68;\n    const startLocation = scrollSnaps[index.get()];\n    const location = Vector1D(startLocation);\n    const offsetLocation = Vector1D(startLocation);\n    const target = Vector1D(startLocation);\n    const scrollBody = ScrollBody(location, offsetLocation, target, duration, friction);\n    const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n    const scrollTo = ScrollTo(animation, index, indexPrevious, scrollTarget, target, eventHandler);\n    const scrollProgress = ScrollProgress(limit);\n    const eventStore = EventStore();\n    const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n    const { slideRegistry } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n    const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore);\n    // Engine\n    const engine = {\n        ownerDocument,\n        ownerWindow,\n        eventHandler,\n        containerRect,\n        slideRects,\n        animation,\n        axis,\n        direction,\n        dragHandler: DragHandler(axis, direction, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n        eventStore,\n        percentOfView,\n        index,\n        indexPrevious,\n        limit,\n        location,\n        offsetLocation,\n        options,\n        resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n        scrollBody,\n        scrollBounds: ScrollBounds(limit, location, target, scrollBody, percentOfView),\n        scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n            location,\n            offsetLocation,\n            target\n        ]),\n        scrollProgress,\n        scrollSnapList: scrollSnaps.map(scrollProgress.get),\n        scrollSnaps,\n        scrollTarget,\n        scrollTo,\n        slideLooper: SlideLooper(axis, direction, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n        slideFocus,\n        slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n        slidesInView,\n        slideIndexes,\n        slideRegistry,\n        slidesToScroll,\n        target,\n        translate: Translate(axis, direction, container)\n    };\n    return engine;\n}\nfunction Animations(ownerWindow) {\n    const timeStep = 1000 / 60;\n    let engines = [];\n    let lastTimeStamp = null;\n    let lag = 0;\n    let animationFrame = 0;\n    function animate(timeStamp) {\n        if (!lastTimeStamp) lastTimeStamp = timeStamp;\n        const elapsed = timeStamp - lastTimeStamp;\n        lastTimeStamp = timeStamp;\n        lag += elapsed;\n        while(lag >= timeStep){\n            engines.forEach(({ animation })=>animation.update());\n            lag -= timeStep;\n        }\n        const lagOffset = mathAbs(lag / timeStep);\n        engines.forEach(({ animation })=>animation.render(lagOffset));\n        if (animationFrame) ownerWindow.requestAnimationFrame(animate);\n    }\n    function start(engine) {\n        if (!engines.includes(engine)) engines.push(engine);\n        if (animationFrame) return;\n        animationFrame = ownerWindow.requestAnimationFrame(animate);\n    }\n    function stop(engine) {\n        engines = engines.filter((e)=>e !== engine);\n        if (engines.length) return;\n        ownerWindow.cancelAnimationFrame(animationFrame);\n        lastTimeStamp = null;\n        lag = 0;\n        animationFrame = 0;\n    }\n    function reset() {\n        lastTimeStamp = null;\n        lag = 0;\n    }\n    const self = {\n        start,\n        stop,\n        reset,\n        window: ownerWindow\n    };\n    return self;\n}\nfunction EventHandler() {\n    const listeners = {};\n    let api;\n    function init(emblaApi) {\n        api = emblaApi;\n    }\n    function getListeners(evt) {\n        return listeners[evt] || [];\n    }\n    function emit(evt) {\n        getListeners(evt).forEach((e)=>e(api, evt));\n        return self;\n    }\n    function on(evt, cb) {\n        listeners[evt] = getListeners(evt).concat([\n            cb\n        ]);\n        return self;\n    }\n    function off(evt, cb) {\n        listeners[evt] = getListeners(evt).filter((e)=>e !== cb);\n        return self;\n    }\n    const self = {\n        init,\n        emit,\n        off,\n        on\n    };\n    return self;\n}\nconst defaultOptions = {\n    align: \"center\",\n    axis: \"x\",\n    container: null,\n    slides: null,\n    containScroll: \"trimSnaps\",\n    direction: \"ltr\",\n    slidesToScroll: 1,\n    inViewThreshold: 0,\n    breakpoints: {},\n    dragFree: false,\n    dragThreshold: 10,\n    loop: false,\n    skipSnaps: false,\n    duration: 25,\n    startIndex: 0,\n    active: true,\n    watchDrag: true,\n    watchResize: true,\n    watchSlides: true\n};\nfunction OptionsHandler(ownerWindow) {\n    function mergeOptions(optionsA, optionsB) {\n        return objectsMergeDeep(optionsA, optionsB || {});\n    }\n    function optionsAtMedia(options) {\n        const optionsAtMedia = options.breakpoints || {};\n        const matchedMediaOptions = objectKeys(optionsAtMedia).filter((media)=>ownerWindow.matchMedia(media).matches).map((media)=>optionsAtMedia[media]).reduce((a, mediaOption)=>mergeOptions(a, mediaOption), {});\n        return mergeOptions(options, matchedMediaOptions);\n    }\n    function optionsMediaQueries(optionsList) {\n        return optionsList.map((options)=>objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries)=>acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n    }\n    const self = {\n        mergeOptions,\n        optionsAtMedia,\n        optionsMediaQueries\n    };\n    return self;\n}\nfunction PluginsHandler(optionsHandler) {\n    let activePlugins = [];\n    function init(emblaApi, plugins) {\n        activePlugins = plugins.filter(({ options })=>optionsHandler.optionsAtMedia(options).active !== false);\n        activePlugins.forEach((plugin)=>plugin.init(emblaApi, optionsHandler));\n        return plugins.reduce((map, plugin)=>Object.assign(map, {\n                [plugin.name]: plugin\n            }), {});\n    }\n    function destroy() {\n        activePlugins = activePlugins.filter((plugin)=>plugin.destroy());\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n    const ownerDocument = root.ownerDocument;\n    const ownerWindow = ownerDocument.defaultView;\n    const optionsHandler = OptionsHandler(ownerWindow);\n    const pluginsHandler = PluginsHandler(optionsHandler);\n    const mediaHandlers = EventStore();\n    const documentVisibleHandler = EventStore();\n    const eventHandler = EventHandler();\n    const { animationRealms } = EmblaCarousel;\n    const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler;\n    const { on, off, emit } = eventHandler;\n    const reInit = reActivate;\n    let destroyed = false;\n    let engine;\n    let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n    let options = mergeOptions(optionsBase);\n    let pluginList = [];\n    let pluginApis;\n    let container;\n    let slides;\n    function storeElements() {\n        const { container: userContainer, slides: userSlides } = options;\n        const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n        container = customContainer || root.children[0];\n        const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n        slides = [].slice.call(customSlides || container.children);\n    }\n    function createEngine(options, animations) {\n        const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler, animations);\n        if (options.loop && !engine.slideLooper.canLoop()) {\n            const optionsWithoutLoop = Object.assign({}, options, {\n                loop: false\n            });\n            return createEngine(optionsWithoutLoop, animations);\n        }\n        return engine;\n    }\n    function activate(withOptions, withPlugins) {\n        if (destroyed) return;\n        const animationRealm = animationRealms.find((a)=>a.window === ownerWindow);\n        const animations = animationRealm || Animations(ownerWindow);\n        if (!animationRealm) animationRealms.push(animations);\n        optionsBase = mergeOptions(optionsBase, withOptions);\n        options = optionsAtMedia(optionsBase);\n        pluginList = withPlugins || pluginList;\n        storeElements();\n        engine = createEngine(options, animations);\n        optionsMediaQueries([\n            optionsBase,\n            ...pluginList.map(({ options })=>options)\n        ]).forEach((query)=>mediaHandlers.add(query, \"change\", reActivate));\n        if (!options.active) return;\n        engine.translate.to(engine.location.get());\n        engine.slidesInView.init();\n        engine.slideFocus.init();\n        engine.eventHandler.init(self);\n        engine.resizeHandler.init(self);\n        engine.slidesHandler.init(self);\n        documentVisibleHandler.add(ownerDocument, \"visibilitychange\", ()=>{\n            if (ownerDocument.hidden) animations.reset();\n        });\n        if (engine.options.loop) engine.slideLooper.loop();\n        if (container.offsetParent && slides.length) engine.dragHandler.init(self);\n        pluginApis = pluginsHandler.init(self, pluginList);\n    }\n    function reActivate(withOptions, withPlugins) {\n        const startIndex = selectedScrollSnap();\n        deActivate();\n        activate(mergeOptions({\n            startIndex\n        }, withOptions), withPlugins);\n        eventHandler.emit(\"reInit\");\n    }\n    function deActivate() {\n        engine.dragHandler.destroy();\n        engine.animation.stop();\n        engine.eventStore.clear();\n        engine.translate.clear();\n        engine.slideLooper.clear();\n        engine.resizeHandler.destroy();\n        engine.slidesHandler.destroy();\n        engine.slidesInView.destroy();\n        pluginsHandler.destroy();\n        mediaHandlers.clear();\n        documentVisibleHandler.clear();\n    }\n    function destroy() {\n        if (destroyed) return;\n        destroyed = true;\n        mediaHandlers.clear();\n        deActivate();\n        eventHandler.emit(\"destroy\");\n    }\n    function scrollTo(index, jump, direction) {\n        if (!options.active || destroyed) return;\n        engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n        engine.scrollTo.index(index, direction || 0);\n    }\n    function scrollNext(jump) {\n        const next = engine.index.add(1).get();\n        scrollTo(next, jump, -1);\n    }\n    function scrollPrev(jump) {\n        const prev = engine.index.add(-1).get();\n        scrollTo(prev, jump, 1);\n    }\n    function canScrollNext() {\n        const next = engine.index.add(1).get();\n        return next !== selectedScrollSnap();\n    }\n    function canScrollPrev() {\n        const prev = engine.index.add(-1).get();\n        return prev !== selectedScrollSnap();\n    }\n    function scrollSnapList() {\n        return engine.scrollSnapList;\n    }\n    function scrollProgress() {\n        return engine.scrollProgress.get(engine.location.get());\n    }\n    function selectedScrollSnap() {\n        return engine.index.get();\n    }\n    function previousScrollSnap() {\n        return engine.indexPrevious.get();\n    }\n    function slidesInView() {\n        return engine.slidesInView.get();\n    }\n    function slidesNotInView() {\n        return engine.slidesInView.get(false);\n    }\n    function plugins() {\n        return pluginApis;\n    }\n    function internalEngine() {\n        return engine;\n    }\n    function rootNode() {\n        return root;\n    }\n    function containerNode() {\n        return container;\n    }\n    function slideNodes() {\n        return slides;\n    }\n    const self = {\n        canScrollNext,\n        canScrollPrev,\n        containerNode,\n        internalEngine,\n        destroy,\n        off,\n        on,\n        emit,\n        plugins,\n        previousScrollSnap,\n        reInit,\n        rootNode,\n        scrollNext,\n        scrollPrev,\n        scrollProgress,\n        scrollSnapList,\n        scrollTo,\n        selectedScrollSnap,\n        slideNodes,\n        slidesInView,\n        slidesNotInView\n    };\n    activate(userOptions, userPlugins);\n    setTimeout(()=>eventHandler.emit(\"init\"), 0);\n    return self;\n}\nEmblaCarousel.animationRealms = [];\nEmblaCarousel.globalOptions = undefined;\n //# sourceMappingURL=embla-carousel.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwvZXNtL2VtYmxhLWNhcm91c2VsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsU0FBU0MsT0FBTztJQUN2QixPQUFPLE9BQU9BLFlBQVk7QUFDNUI7QUFDQSxTQUFTQyxTQUFTRCxPQUFPO0lBQ3ZCLE9BQU8sT0FBT0EsWUFBWTtBQUM1QjtBQUNBLFNBQVNFLFVBQVVGLE9BQU87SUFDeEIsT0FBTyxPQUFPQSxZQUFZO0FBQzVCO0FBQ0EsU0FBU0csU0FBU0gsT0FBTztJQUN2QixPQUFPSSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUCxhQUFhO0FBQ3JEO0FBQ0EsU0FBU1EsUUFBUUMsQ0FBQztJQUNoQixPQUFPQyxLQUFLQyxHQUFHLENBQUNGO0FBQ2xCO0FBQ0EsU0FBU0csU0FBU0gsQ0FBQztJQUNqQixPQUFPQyxLQUFLRyxJQUFJLENBQUNKO0FBQ25CO0FBQ0EsU0FBU0ssU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQzlCLE9BQU9SLFFBQVFPLFNBQVNDO0FBQzFCO0FBQ0EsU0FBU0MsVUFBVUYsTUFBTSxFQUFFQyxNQUFNO0lBQy9CLElBQUlELFdBQVcsS0FBS0MsV0FBVyxHQUFHLE9BQU87SUFDekMsSUFBSVIsUUFBUU8sV0FBV1AsUUFBUVEsU0FBUyxPQUFPO0lBQy9DLE1BQU1FLE9BQU9KLFNBQVNOLFFBQVFPLFNBQVNQLFFBQVFRO0lBQy9DLE9BQU9SLFFBQVFVLE9BQU9IO0FBQ3hCO0FBQ0EsU0FBU0ksVUFBVUMsS0FBSztJQUN0QixPQUFPQyxXQUFXRCxPQUFPRSxHQUFHLENBQUNDO0FBQy9CO0FBQ0EsU0FBU0MsVUFBVUosS0FBSztJQUN0QixPQUFPQSxLQUFLLENBQUNLLGVBQWVMLE9BQU87QUFDckM7QUFDQSxTQUFTSyxlQUFlTCxLQUFLO0lBQzNCLE9BQU9WLEtBQUtnQixHQUFHLENBQUMsR0FBR04sTUFBTU8sTUFBTSxHQUFHO0FBQ3BDO0FB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bW9kdWxlcy9lbWJsYS1jYXJvdXNlbC9lc20vZW1ibGEtY2Fyb3VzZWwuZXNtLmpzPzJkODAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNOdW1iZXIoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdudW1iZXInO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gbWF0aEFicyhuKSB7XG4gIHJldHVybiBNYXRoLmFicyhuKTtcbn1cbmZ1bmN0aW9uIG1hdGhTaWduKG4pIHtcbiAgcmV0dXJuIE1hdGguc2lnbihuKTtcbn1cbmZ1bmN0aW9uIGRlbHRhQWJzKHZhbHVlQiwgdmFsdWVBKSB7XG4gIHJldHVybiBtYXRoQWJzKHZhbHVlQiAtIHZhbHVlQSk7XG59XG5mdW5jdGlvbiBmYWN0b3JBYnModmFsdWVCLCB2YWx1ZUEpIHtcbiAgaWYgKHZhbHVlQiA9PT0gMCB8fCB2YWx1ZUEgPT09IDApIHJldHVybiAwO1xuICBpZiAobWF0aEFicyh2YWx1ZUIpIDw9IG1hdGhBYnModmFsdWVBKSkgcmV0dXJuIDA7XG4gIGNvbnN0IGRpZmYgPSBkZWx0YUFicyhtYXRoQWJzKHZhbHVlQiksIG1hdGhBYnModmFsdWVBKSk7XG4gIHJldHVybiBtYXRoQWJzKGRpZmYgLyB2YWx1ZUIpO1xufVxuZnVuY3Rpb24gYXJyYXlLZXlzKGFycmF5KSB7XG4gIHJldHVybiBvYmplY3RLZXlzKGFycmF5KS5tYXAoTnVtYmVyKTtcbn1cbmZ1bmN0aW9uIGFycmF5TGFzdChhcnJheSkge1xuICByZXR1cm4gYXJyYXlbYXJyYXlMYXN0SW5kZXgoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIGFycmF5TGFzdEluZGV4KGFycmF5KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGFycmF5SXNMYXN0SW5kZXgoYXJyYXksIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA9PT0gYXJyYXlMYXN0SW5kZXgoYXJyYXkpO1xufVxuZnVuY3Rpb24gYXJyYXlGcm9tTnVtYmVyKG4sIHN0YXJ0QXQgPSAwKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKEFycmF5KG4pLCAoXywgaSkgPT4gc3RhcnRBdCArIGkpO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG59XG5mdW5jdGlvbiBvYmplY3RzTWVyZ2VEZWVwKG9iamVjdEEsIG9iamVjdEIpIHtcbiAgcmV0dXJuIFtvYmplY3RBLCBvYmplY3RCXS5yZWR1Y2UoKG1lcmdlZE9iamVjdHMsIGN1cnJlbnRPYmplY3QpID0+IHtcbiAgICBvYmplY3RLZXlzKGN1cnJlbnRPYmplY3QpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlQSA9IG1lcmdlZE9iamVjdHNba2V5XTtcbiAgICAgIGNvbnN0IHZhbHVlQiA9IGN1cnJlbnRPYmplY3Rba2V5XTtcbiAgICAgIGNvbnN0IGFyZU9iamVjdHMgPSBpc09iamVjdCh2YWx1ZUEpICYmIGlzT2JqZWN0KHZhbHVlQik7XG4gICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBhcmVPYmplY3RzID8gb2JqZWN0c01lcmdlRGVlcCh2YWx1ZUEsIHZhbHVlQikgOiB2YWx1ZUI7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZE9iamVjdHM7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSB7XG4gIHJldHVybiB0eXBlb2Ygb3duZXJXaW5kb3cuTW91c2VFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZ0IGluc3RhbmNlb2Ygb3duZXJXaW5kb3cuTW91c2VFdmVudDtcbn1cblxuZnVuY3Rpb24gQWxpZ25tZW50KGFsaWduLCB2aWV3U2l6ZSkge1xuICBjb25zdCBwcmVkZWZpbmVkID0ge1xuICAgIHN0YXJ0LFxuICAgIGNlbnRlcixcbiAgICBlbmRcbiAgfTtcbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZnVuY3Rpb24gY2VudGVyKG4pIHtcbiAgICByZXR1cm4gZW5kKG4pIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBlbmQobikge1xuICAgIHJldHVybiB2aWV3U2l6ZSAtIG47XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZShuLCBpbmRleCkge1xuICAgIGlmIChpc1N0cmluZyhhbGlnbikpIHJldHVybiBwcmVkZWZpbmVkW2FsaWduXShuKTtcbiAgICByZXR1cm4gYWxpZ24odmlld1NpemUsIG4sIGluZGV4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lYXN1cmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEF4aXMoYXhpcywgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IHNjcm9sbCA9IGF4aXMgPT09ICd5JyA/ICd5JyA6ICd4JztcbiAgY29uc3QgY3Jvc3MgPSBheGlzID09PSAneScgPyAneCcgOiAneSc7XG4gIGNvbnN0IHN0YXJ0RWRnZSA9IGdldFN0YXJ0RWRnZSgpO1xuICBjb25zdCBlbmRFZGdlID0gZ2V0RW5kRWRnZSgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZShub2RlUmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IG5vZGVSZWN0O1xuICAgIHJldHVybiBzY3JvbGwgPT09ICd4JyA/IHdpZHRoIDogaGVpZ2h0O1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXJ0RWRnZSgpIHtcbiAgICBpZiAoc2Nyb2xsID09PSAneScpIHJldHVybiAndG9wJztcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW5kRWRnZSgpIHtcbiAgICBpZiAoc2Nyb2xsID09PSAneScpIHJldHVybiAnYm90dG9tJztcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncnRsJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzY3JvbGwsXG4gICAgY3Jvc3MsXG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2UsXG4gICAgbWVhc3VyZVNpemVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIExpbWl0KG1pbiA9IDAsIG1heCA9IDApIHtcbiAgY29uc3QgbGVuZ3RoID0gbWF0aEFicyhtaW4gLSBtYXgpO1xuICBmdW5jdGlvbiByZWFjaGVkTWluKG4pIHtcbiAgICByZXR1cm4gbiA8IG1pbjtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkTWF4KG4pIHtcbiAgICByZXR1cm4gbiA+IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkQW55KG4pIHtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSB8fCByZWFjaGVkTWF4KG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihuKSB7XG4gICAgaWYgKCFyZWFjaGVkQW55KG4pKSByZXR1cm4gbjtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSA/IG1pbiA6IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPZmZzZXQobikge1xuICAgIGlmICghbGVuZ3RoKSByZXR1cm4gbjtcbiAgICByZXR1cm4gbiAtIGxlbmd0aCAqIE1hdGguY2VpbCgobiAtIG1heCkgLyBsZW5ndGgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbGVuZ3RoLFxuICAgIG1heCxcbiAgICBtaW4sXG4gICAgY29uc3RyYWluLFxuICAgIHJlYWNoZWRBbnksXG4gICAgcmVhY2hlZE1heCxcbiAgICByZWFjaGVkTWluLFxuICAgIHJlbW92ZU9mZnNldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQ291bnRlcihtYXgsIHN0YXJ0LCBsb29wKSB7XG4gIGNvbnN0IHtcbiAgICBjb25zdHJhaW5cbiAgfSA9IExpbWl0KDAsIG1heCk7XG4gIGNvbnN0IGxvb3BFbmQgPSBtYXggKyAxO1xuICBsZXQgY291bnRlciA9IHdpdGhpbkxpbWl0KHN0YXJ0KTtcbiAgZnVuY3Rpb24gd2l0aGluTGltaXQobikge1xuICAgIHJldHVybiAhbG9vcCA/IGNvbnN0cmFpbihuKSA6IG1hdGhBYnMoKGxvb3BFbmQgKyBuKSAlIGxvb3BFbmQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxuICBmdW5jdGlvbiBzZXQobikge1xuICAgIGNvdW50ZXIgPSB3aXRoaW5MaW1pdChuKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHJldHVybiBjbG9uZSgpLnNldChnZXQoKSArIG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBDb3VudGVyKG1heCwgZ2V0KCksIGxvb3ApO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICBhZGQsXG4gICAgY2xvbmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgY29uc3Qgc2lnbiA9IGRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAtMSA6IDE7XG4gIGZ1bmN0aW9uIGFwcGx5KG4pIHtcbiAgICByZXR1cm4gbiAqIHNpZ247XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBhcHBseVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRXZlbnRTdG9yZSgpIHtcbiAgbGV0IGxpc3RlbmVycyA9IFtdO1xuICBmdW5jdGlvbiBhZGQobm9kZSwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pIHtcbiAgICBsZXQgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBub2RlKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lciA9ICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVnYWN5TWVkaWFRdWVyeUxpc3QgPSBub2RlO1xuICAgICAgbGVnYWN5TWVkaWFRdWVyeUxpc3QuYWRkTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgICByZW1vdmVMaXN0ZW5lciA9ICgpID0+IGxlZ2FjeU1lZGlhUXVlcnlMaXN0LnJlbW92ZUxpc3RlbmVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMucHVzaChyZW1vdmVMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihyZW1vdmUgPT4gcmVtb3ZlKCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYWRkLFxuICAgIGNsZWFyXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBEcmFnSGFuZGxlcihheGlzLCBkaXJlY3Rpb24sIHJvb3ROb2RlLCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgdGFyZ2V0LCBkcmFnVHJhY2tlciwgbG9jYXRpb24sIGFuaW1hdGlvbiwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIHNjcm9sbFRhcmdldCwgaW5kZXgsIGV2ZW50SGFuZGxlciwgcGVyY2VudE9mVmlldywgZHJhZ0ZyZWUsIGRyYWdUaHJlc2hvbGQsIHNraXBTbmFwcywgYmFzZUZyaWN0aW9uLCB3YXRjaERyYWcpIHtcbiAgY29uc3Qge1xuICAgIGNyb3NzOiBjcm9zc0F4aXNcbiAgfSA9IGF4aXM7XG4gIGNvbnN0IGZvY3VzTm9kZXMgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuICBjb25zdCBub25QYXNzaXZlRXZlbnQgPSB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfTtcbiAgY29uc3QgaW5pdEV2ZW50cyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZHJhZ0V2ZW50cyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZ29Ub05leHRUaHJlc2hvbGQgPSBMaW1pdCg1MCwgMjI1KS5jb25zdHJhaW4ocGVyY2VudE9mVmlldy5tZWFzdXJlKDIwKSk7XG4gIGNvbnN0IHNuYXBGb3JjZUJvb3N0ID0ge1xuICAgIG1vdXNlOiAzMDAsXG4gICAgdG91Y2g6IDQwMFxuICB9O1xuICBjb25zdCBmcmVlRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogNTAwLFxuICAgIHRvdWNoOiA2MDBcbiAgfTtcbiAgY29uc3QgYmFzZVNwZWVkID0gZHJhZ0ZyZWUgPyA0MyA6IDI1O1xuICBsZXQgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgbGV0IHN0YXJ0U2Nyb2xsID0gMDtcbiAgbGV0IHN0YXJ0Q3Jvc3MgPSAwO1xuICBsZXQgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICBsZXQgcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICBsZXQgcHJldmVudENsaWNrID0gZmFsc2U7XG4gIGxldCBpc01vdXNlID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBpZiAoIXdhdGNoRHJhZykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRvd25JZkFsbG93ZWQoZXZ0KSB7XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoRHJhZykgfHwgd2F0Y2hEcmFnKGVtYmxhQXBpLCBldnQpKSBkb3duKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSByb290Tm9kZTtcbiAgICBpbml0RXZlbnRzLmFkZChub2RlLCAnZHJhZ3N0YXJ0JywgZXZ0ID0+IGV2dC5wcmV2ZW50RGVmYXVsdCgpLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2htb3ZlJywgKCkgPT4gdW5kZWZpbmVkLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCAoKSA9PiB1bmRlZmluZWQpLmFkZChub2RlLCAndG91Y2hzdGFydCcsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAnbW91c2Vkb3duJywgZG93bklmQWxsb3dlZCkuYWRkKG5vZGUsICd0b3VjaGNhbmNlbCcsIHVwKS5hZGQobm9kZSwgJ2NvbnRleHRtZW51JywgdXApLmFkZChub2RlLCAnY2xpY2snLCBjbGljaywgdHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpbml0RXZlbnRzLmNsZWFyKCk7XG4gICAgZHJhZ0V2ZW50cy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZERyYWdFdmVudHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGlzTW91c2UgPyBvd25lckRvY3VtZW50IDogcm9vdE5vZGU7XG4gICAgZHJhZ0V2ZW50cy5hZGQobm9kZSwgJ3RvdWNobW92ZScsIG1vdmUsIG5vblBhc3NpdmVFdmVudCkuYWRkKG5vZGUsICd0b3VjaGVuZCcsIHVwKS5hZGQobm9kZSwgJ21vdXNlbW92ZScsIG1vdmUsIG5vblBhc3NpdmVFdmVudCkuYWRkKG5vZGUsICdtb3VzZXVwJywgdXApO1xuICB9XG4gIGZ1bmN0aW9uIGlzRm9jdXNOb2RlKG5vZGUpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUgfHwgJyc7XG4gICAgcmV0dXJuIGZvY3VzTm9kZXMuaW5jbHVkZXMobm9kZU5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcmNlQm9vc3QoKSB7XG4gICAgY29uc3QgYm9vc3QgPSBkcmFnRnJlZSA/IGZyZWVGb3JjZUJvb3N0IDogc25hcEZvcmNlQm9vc3Q7XG4gICAgY29uc3QgdHlwZSA9IGlzTW91c2UgPyAnbW91c2UnIDogJ3RvdWNoJztcbiAgICByZXR1cm4gYm9vc3RbdHlwZV07XG4gIH1cbiAgZnVuY3Rpb24gYWxsb3dlZEZvcmNlKGZvcmNlLCB0YXJnZXRDaGFuZ2VkKSB7XG4gICAgY29uc3QgbmV4dCA9IGluZGV4LmFkZChtYXRoU2lnbihmb3JjZSkgKiAtMSk7XG4gICAgY29uc3QgYmFzZUZvcmNlID0gc2Nyb2xsVGFyZ2V0LmJ5RGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSkuZGlzdGFuY2U7XG4gICAgaWYgKGRyYWdGcmVlIHx8IG1hdGhBYnMoZm9yY2UpIDwgZ29Ub05leHRUaHJlc2hvbGQpIHJldHVybiBiYXNlRm9yY2U7XG4gICAgaWYgKHNraXBTbmFwcyAmJiB0YXJnZXRDaGFuZ2VkKSByZXR1cm4gYmFzZUZvcmNlICogMC41O1xuICAgIHJldHVybiBzY3JvbGxUYXJnZXQuYnlJbmRleChuZXh0LmdldCgpLCAwKS5kaXN0YW5jZTtcbiAgfVxuICBmdW5jdGlvbiBkb3duKGV2dCkge1xuICAgIGNvbnN0IGlzTW91c2VFdnQgPSBpc01vdXNlRXZlbnQoZXZ0LCBvd25lcldpbmRvdyk7XG4gICAgaXNNb3VzZSA9IGlzTW91c2VFdnQ7XG4gICAgaWYgKGlzTW91c2VFdnQgJiYgZXZ0LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgIGlmIChpc0ZvY3VzTm9kZShldnQudGFyZ2V0KSkgcmV0dXJuO1xuICAgIHByZXZlbnRDbGljayA9IGRyYWdGcmVlICYmIGlzTW91c2VFdnQgJiYgIWV2dC5idXR0b25zICYmIGlzTW92aW5nO1xuICAgIGlzTW92aW5nID0gZGVsdGFBYnModGFyZ2V0LmdldCgpLCBsb2NhdGlvbi5nZXQoKSkgPj0gMjtcbiAgICBwb2ludGVySXNEb3duID0gdHJ1ZTtcbiAgICBkcmFnVHJhY2tlci5wb2ludGVyRG93bihldnQpO1xuICAgIHNjcm9sbEJvZHkudXNlRnJpY3Rpb24oMCkudXNlRHVyYXRpb24oMCk7XG4gICAgdGFyZ2V0LnNldChsb2NhdGlvbik7XG4gICAgYWRkRHJhZ0V2ZW50cygpO1xuICAgIHN0YXJ0U2Nyb2xsID0gZHJhZ1RyYWNrZXIucmVhZFBvaW50KGV2dCk7XG4gICAgc3RhcnRDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3BvaW50ZXJEb3duJyk7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZShldnQpIHtcbiAgICBjb25zdCBsYXN0U2Nyb2xsID0gZHJhZ1RyYWNrZXIucmVhZFBvaW50KGV2dCk7XG4gICAgY29uc3QgbGFzdENyb3NzID0gZHJhZ1RyYWNrZXIucmVhZFBvaW50KGV2dCwgY3Jvc3NBeGlzKTtcbiAgICBjb25zdCBkaWZmU2Nyb2xsID0gZGVsdGFBYnMobGFzdFNjcm9sbCwgc3RhcnRTY3JvbGwpO1xuICAgIGNvbnN0IGRpZmZDcm9zcyA9IGRlbHRhQWJzKGxhc3RDcm9zcywgc3RhcnRDcm9zcyk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsICYmICFpc01vdXNlKSB7XG4gICAgICBpZiAoIWV2dC5jYW5jZWxhYmxlKSByZXR1cm4gdXAoZXZ0KTtcbiAgICAgIHByZXZlbnRTY3JvbGwgPSBkaWZmU2Nyb2xsID4gZGlmZkNyb3NzO1xuICAgICAgaWYgKCFwcmV2ZW50U2Nyb2xsKSByZXR1cm4gdXAoZXZ0KTtcbiAgICB9XG4gICAgY29uc3QgZGlmZiA9IGRyYWdUcmFja2VyLnBvaW50ZXJNb3ZlKGV2dCk7XG4gICAgaWYgKGRpZmZTY3JvbGwgPiBkcmFnVGhyZXNob2xkKSBwcmV2ZW50Q2xpY2sgPSB0cnVlO1xuICAgIHNjcm9sbEJvZHkudXNlRnJpY3Rpb24oMC4zKS51c2VEdXJhdGlvbigxKTtcbiAgICBhbmltYXRpb24uc3RhcnQoKTtcbiAgICB0YXJnZXQuYWRkKGRpcmVjdGlvbi5hcHBseShkaWZmKSk7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZnVuY3Rpb24gdXAoZXZ0KSB7XG4gICAgY29uc3QgY3VycmVudExvY2F0aW9uID0gc2Nyb2xsVGFyZ2V0LmJ5RGlzdGFuY2UoMCwgZmFsc2UpO1xuICAgIGNvbnN0IHRhcmdldENoYW5nZWQgPSBjdXJyZW50TG9jYXRpb24uaW5kZXggIT09IGluZGV4LmdldCgpO1xuICAgIGNvbnN0IHJhd0ZvcmNlID0gZHJhZ1RyYWNrZXIucG9pbnRlclVwKGV2dCkgKiBmb3JjZUJvb3N0KCk7XG4gICAgY29uc3QgZm9yY2UgPSBhbGxvd2VkRm9yY2UoZGlyZWN0aW9uLmFwcGx5KHJhd0ZvcmNlKSwgdGFyZ2V0Q2hhbmdlZCk7XG4gICAgY29uc3QgZm9yY2VGYWN0b3IgPSBmYWN0b3JBYnMocmF3Rm9yY2UsIGZvcmNlKTtcbiAgICBjb25zdCBzcGVlZCA9IGJhc2VTcGVlZCAtIDEwICogZm9yY2VGYWN0b3I7XG4gICAgY29uc3QgZnJpY3Rpb24gPSBiYXNlRnJpY3Rpb24gKyBmb3JjZUZhY3RvciAvIDUwO1xuICAgIHByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgICBwb2ludGVySXNEb3duID0gZmFsc2U7XG4gICAgZHJhZ0V2ZW50cy5jbGVhcigpO1xuICAgIHNjcm9sbEJvZHkudXNlRHVyYXRpb24oc3BlZWQpLnVzZUZyaWN0aW9uKGZyaWN0aW9uKTtcbiAgICBzY3JvbGxUby5kaXN0YW5jZShmb3JjZSwgIWRyYWdGcmVlKTtcbiAgICBpc01vdXNlID0gZmFsc2U7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3BvaW50ZXJVcCcpO1xuICB9XG4gIGZ1bmN0aW9uIGNsaWNrKGV2dCkge1xuICAgIGlmIChwcmV2ZW50Q2xpY2spIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bigpIHtcbiAgICByZXR1cm4gcG9pbnRlcklzRG93bjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgcG9pbnRlckRvd24sXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ1RyYWNrZXIoYXhpcywgb3duZXJXaW5kb3cpIHtcbiAgY29uc3QgbG9nSW50ZXJ2YWwgPSAxNzA7XG4gIGxldCBzdGFydEV2ZW50O1xuICBsZXQgbGFzdEV2ZW50O1xuICBmdW5jdGlvbiByZWFkVGltZShldnQpIHtcbiAgICByZXR1cm4gZXZ0LnRpbWVTdGFtcDtcbiAgfVxuICBmdW5jdGlvbiByZWFkUG9pbnQoZXZ0LCBldnRBeGlzKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBldnRBeGlzIHx8IGF4aXMuc2Nyb2xsO1xuICAgIGNvbnN0IGNvb3JkID0gYGNsaWVudCR7cHJvcGVydHkgPT09ICd4JyA/ICdYJyA6ICdZJ31gO1xuICAgIHJldHVybiAoaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpID8gZXZ0IDogZXZ0LnRvdWNoZXNbMF0pW2Nvb3JkXTtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyRG93bihldnQpIHtcbiAgICBzdGFydEV2ZW50ID0gZXZ0O1xuICAgIGxhc3RFdmVudCA9IGV2dDtcbiAgICByZXR1cm4gcmVhZFBvaW50KGV2dCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1vdmUoZXZ0KSB7XG4gICAgY29uc3QgZGlmZiA9IHJlYWRQb2ludChldnQpIC0gcmVhZFBvaW50KGxhc3RFdmVudCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IHJlYWRUaW1lKGV2dCkgLSByZWFkVGltZShzdGFydEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGxhc3RFdmVudCA9IGV2dDtcbiAgICBpZiAoZXhwaXJlZCkgc3RhcnRFdmVudCA9IGV2dDtcbiAgICByZXR1cm4gZGlmZjtcbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyVXAoZXZ0KSB7XG4gICAgaWYgKCFzdGFydEV2ZW50IHx8ICFsYXN0RXZlbnQpIHJldHVybiAwO1xuICAgIGNvbnN0IGRpZmZEcmFnID0gcmVhZFBvaW50KGxhc3RFdmVudCkgLSByZWFkUG9pbnQoc3RhcnRFdmVudCk7XG4gICAgY29uc3QgZGlmZlRpbWUgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCk7XG4gICAgY29uc3QgZXhwaXJlZCA9IHJlYWRUaW1lKGV2dCkgLSByZWFkVGltZShsYXN0RXZlbnQpID4gbG9nSW50ZXJ2YWw7XG4gICAgY29uc3QgZm9yY2UgPSBkaWZmRHJhZyAvIGRpZmZUaW1lO1xuICAgIGNvbnN0IGlzRmxpY2sgPSBkaWZmVGltZSAmJiAhZXhwaXJlZCAmJiBtYXRoQWJzKGZvcmNlKSA+IDAuMTtcbiAgICByZXR1cm4gaXNGbGljayA/IGZvcmNlIDogMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHBvaW50ZXJEb3duLFxuICAgIHBvaW50ZXJNb3ZlLFxuICAgIHBvaW50ZXJVcCxcbiAgICByZWFkUG9pbnRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIE5vZGVSZWN0cygpIHtcbiAgZnVuY3Rpb24gbWVhc3VyZShub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0VG9wLFxuICAgICAgb2Zmc2V0TGVmdCxcbiAgICAgIG9mZnNldFdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoLFxuICAgICAgYm90dG9tOiBvZmZzZXRUb3AgKyBvZmZzZXRIZWlnaHQsXG4gICAgICBsZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgd2lkdGg6IG9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHRcbiAgICB9O1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBQZXJjZW50T2ZWaWV3KHZpZXdTaXplKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobikge1xuICAgIHJldHVybiB2aWV3U2l6ZSAqIChuIC8gMTAwKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG1lYXN1cmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFJlc2l6ZUhhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIG93bmVyV2luZG93LCBzbGlkZXMsIGF4aXMsIHdhdGNoUmVzaXplLCBub2RlUmVjdHMpIHtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyO1xuICBsZXQgY29udGFpbmVyU2l6ZTtcbiAgbGV0IHNsaWRlU2l6ZXMgPSBbXTtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBmdW5jdGlvbiByZWFkU2l6ZShub2RlKSB7XG4gICAgcmV0dXJuIGF4aXMubWVhc3VyZVNpemUobm9kZVJlY3RzLm1lYXN1cmUobm9kZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBpZiAoIXdhdGNoUmVzaXplKSByZXR1cm47XG4gICAgY29udGFpbmVyU2l6ZSA9IHJlYWRTaXplKGNvbnRhaW5lcik7XG4gICAgc2xpZGVTaXplcyA9IHNsaWRlcy5tYXAocmVhZFNpemUpO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhlbnRyaWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgaXNDb250YWluZXIgPSBlbnRyeS50YXJnZXQgPT09IGNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IHNsaWRlcy5pbmRleE9mKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGxhc3RTaXplID0gaXNDb250YWluZXIgPyBjb250YWluZXJTaXplIDogc2xpZGVTaXplc1tzbGlkZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHJlYWRTaXplKGlzQ29udGFpbmVyID8gY29udGFpbmVyIDogc2xpZGVzW3NsaWRlSW5kZXhdKTtcbiAgICAgICAgY29uc3QgZGlmZlNpemUgPSBtYXRoQWJzKG5ld1NpemUgLSBsYXN0U2l6ZSk7XG4gICAgICAgIGlmIChkaWZmU2l6ZSA+PSAwLjUpIHtcbiAgICAgICAgICBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgZW1ibGFBcGkucmVJbml0KCk7XG4gICAgICAgICAgICBldmVudEhhbmRsZXIuZW1pdCgncmVzaXplJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoUmVzaXplKSB8fCB3YXRjaFJlc2l6ZShlbWJsYUFwaSwgZW50cmllcykpIHtcbiAgICAgICAgZGVmYXVsdENhbGxiYWNrKGVudHJpZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG9ic2VydmVOb2RlcyA9IFtjb250YWluZXJdLmNvbmNhdChzbGlkZXMpO1xuICAgIG9ic2VydmVOb2Rlcy5mb3JFYWNoKG5vZGUgPT4gcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShub2RlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAocmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxCb2R5KGxvY2F0aW9uLCBvZmZzZXRMb2NhdGlvbiwgdGFyZ2V0LCBiYXNlRHVyYXRpb24sIGJhc2VGcmljdGlvbikge1xuICBsZXQgYm9keVZlbG9jaXR5ID0gMDtcbiAgbGV0IHNjcm9sbERpcmVjdGlvbiA9IDA7XG4gIGxldCBzY3JvbGxEdXJhdGlvbiA9IGJhc2VEdXJhdGlvbjtcbiAgbGV0IHNjcm9sbEZyaWN0aW9uID0gYmFzZUZyaWN0aW9uO1xuICBsZXQgcmF3TG9jYXRpb24gPSBsb2NhdGlvbi5nZXQoKTtcbiAgbGV0IHJhd0xvY2F0aW9uUHJldmlvdXMgPSAwO1xuICBmdW5jdGlvbiBzZWVrKCkge1xuICAgIGNvbnN0IGRpZmYgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBpc0luc3RhbnQgPSAhc2Nyb2xsRHVyYXRpb247XG4gICAgbGV0IGRpcmVjdGlvbkRpZmYgPSAwO1xuICAgIGlmIChpc0luc3RhbnQpIHtcbiAgICAgIGJvZHlWZWxvY2l0eSA9IDA7XG4gICAgICBsb2NhdGlvbi5zZXQodGFyZ2V0KTtcbiAgICAgIGRpcmVjdGlvbkRpZmYgPSBkaWZmO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5VmVsb2NpdHkgKz0gZGlmZiAvIHNjcm9sbER1cmF0aW9uO1xuICAgICAgYm9keVZlbG9jaXR5ICo9IHNjcm9sbEZyaWN0aW9uO1xuICAgICAgcmF3TG9jYXRpb24gKz0gYm9keVZlbG9jaXR5O1xuICAgICAgbG9jYXRpb24uYWRkKGJvZHlWZWxvY2l0eSk7XG4gICAgICBkaXJlY3Rpb25EaWZmID0gcmF3TG9jYXRpb24gLSByYXdMb2NhdGlvblByZXZpb3VzO1xuICAgIH1cbiAgICBzY3JvbGxEaXJlY3Rpb24gPSBtYXRoU2lnbihkaXJlY3Rpb25EaWZmKTtcbiAgICByYXdMb2NhdGlvblByZXZpb3VzID0gcmF3TG9jYXRpb247XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gc2V0dGxlZCgpIHtcbiAgICBjb25zdCBkaWZmID0gdGFyZ2V0LmdldCgpIC0gb2Zmc2V0TG9jYXRpb24uZ2V0KCk7XG4gICAgcmV0dXJuIG1hdGhBYnMoZGlmZikgPCAwLjAwMTtcbiAgfVxuICBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRHVyYXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBzY3JvbGxEaXJlY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gdmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIGJvZHlWZWxvY2l0eTtcbiAgfVxuICBmdW5jdGlvbiB1c2VCYXNlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHVzZUR1cmF0aW9uKGJhc2VEdXJhdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmFzZUZyaWN0aW9uKCkge1xuICAgIHJldHVybiB1c2VGcmljdGlvbihiYXNlRnJpY3Rpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUR1cmF0aW9uKG4pIHtcbiAgICBzY3JvbGxEdXJhdGlvbiA9IG47XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRnJpY3Rpb24obikge1xuICAgIHNjcm9sbEZyaWN0aW9uID0gbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGRpcmVjdGlvbixcbiAgICBkdXJhdGlvbixcbiAgICB2ZWxvY2l0eSxcbiAgICBzZWVrLFxuICAgIHNldHRsZWQsXG4gICAgdXNlQmFzZUZyaWN0aW9uLFxuICAgIHVzZUJhc2VEdXJhdGlvbixcbiAgICB1c2VGcmljdGlvbixcbiAgICB1c2VEdXJhdGlvblxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm91bmRzKGxpbWl0LCBsb2NhdGlvbiwgdGFyZ2V0LCBzY3JvbGxCb2R5LCBwZXJjZW50T2ZWaWV3KSB7XG4gIGNvbnN0IHB1bGxCYWNrVGhyZXNob2xkID0gcGVyY2VudE9mVmlldy5tZWFzdXJlKDEwKTtcbiAgY29uc3QgZWRnZU9mZnNldFRvbGVyYW5jZSA9IHBlcmNlbnRPZlZpZXcubWVhc3VyZSg1MCk7XG4gIGNvbnN0IGZyaWN0aW9uTGltaXQgPSBMaW1pdCgwLjEsIDAuOTkpO1xuICBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gc2hvdWxkQ29uc3RyYWluKCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghbGltaXQucmVhY2hlZEFueSh0YXJnZXQuZ2V0KCkpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFsaW1pdC5yZWFjaGVkQW55KGxvY2F0aW9uLmdldCgpKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihwb2ludGVyRG93bikge1xuICAgIGlmICghc2hvdWxkQ29uc3RyYWluKCkpIHJldHVybjtcbiAgICBjb25zdCBlZGdlID0gbGltaXQucmVhY2hlZE1pbihsb2NhdGlvbi5nZXQoKSkgPyAnbWluJyA6ICdtYXgnO1xuICAgIGNvbnN0IGRpZmZUb0VkZ2UgPSBtYXRoQWJzKGxpbWl0W2VkZ2VdIC0gbG9jYXRpb24uZ2V0KCkpO1xuICAgIGNvbnN0IGRpZmZUb1RhcmdldCA9IHRhcmdldC5nZXQoKSAtIGxvY2F0aW9uLmdldCgpO1xuICAgIGNvbnN0IGZyaWN0aW9uID0gZnJpY3Rpb25MaW1pdC5jb25zdHJhaW4oZGlmZlRvRWRnZSAvIGVkZ2VPZmZzZXRUb2xlcmFuY2UpO1xuICAgIHRhcmdldC5zdWJ0cmFjdChkaWZmVG9UYXJnZXQgKiBmcmljdGlvbik7XG4gICAgaWYgKCFwb2ludGVyRG93biAmJiBtYXRoQWJzKGRpZmZUb1RhcmdldCkgPCBwdWxsQmFja1RocmVzaG9sZCkge1xuICAgICAgdGFyZ2V0LnNldChsaW1pdC5jb25zdHJhaW4odGFyZ2V0LmdldCgpKSk7XG4gICAgICBzY3JvbGxCb2R5LnVzZUR1cmF0aW9uKDI1KS51c2VCYXNlRnJpY3Rpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlQWN0aXZlKGFjdGl2ZSkge1xuICAgIGRpc2FibGVkID0gIWFjdGl2ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNvbnN0cmFpbixcbiAgICB0b2dnbGVBY3RpdmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbENvbnRhaW4odmlld1NpemUsIGNvbnRlbnRTaXplLCBzbmFwc0FsaWduZWQsIGNvbnRhaW5TY3JvbGwsIHBpeGVsVG9sZXJhbmNlKSB7XG4gIGNvbnN0IHNjcm9sbEJvdW5kcyA9IExpbWl0KC1jb250ZW50U2l6ZSArIHZpZXdTaXplLCAwKTtcbiAgY29uc3Qgc25hcHNCb3VuZGVkID0gbWVhc3VyZUJvdW5kZWQoKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbkxpbWl0ID0gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpO1xuICBjb25zdCBzbmFwc0NvbnRhaW5lZCA9IG1lYXN1cmVDb250YWluZWQoKTtcbiAgZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpIHtcbiAgICBjb25zdCBzdGFydFNuYXAgPSBzbmFwc0JvdW5kZWRbMF07XG4gICAgY29uc3QgZW5kU25hcCA9IGFycmF5TGFzdChzbmFwc0JvdW5kZWQpO1xuICAgIGNvbnN0IG1pbiA9IHNuYXBzQm91bmRlZC5sYXN0SW5kZXhPZihzdGFydFNuYXApO1xuICAgIGNvbnN0IG1heCA9IHNuYXBzQm91bmRlZC5pbmRleE9mKGVuZFNuYXApICsgMTtcbiAgICByZXR1cm4gTGltaXQobWluLCBtYXgpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVCb3VuZGVkKCkge1xuICAgIHJldHVybiBzbmFwc0FsaWduZWQubWFwKChzbmFwQWxpZ25lZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSAhaW5kZXg7XG4gICAgICBjb25zdCBpc0xhc3QgPSBhcnJheUlzTGFzdEluZGV4KHNuYXBzQWxpZ25lZCwgaW5kZXgpO1xuICAgICAgaWYgKGlzRmlyc3QpIHJldHVybiBzY3JvbGxCb3VuZHMubWF4O1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIHNjcm9sbEJvdW5kcy5taW47XG4gICAgICByZXR1cm4gc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihzbmFwQWxpZ25lZCk7XG4gICAgfSkubWFwKHNjcm9sbEJvdW5kID0+IHBhcnNlRmxvYXQoc2Nyb2xsQm91bmQudG9GaXhlZCgzKSkpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVDb250YWluZWQoKSB7XG4gICAgaWYgKGNvbnRlbnRTaXplIDw9IHZpZXdTaXplICsgcGl4ZWxUb2xlcmFuY2UpIHJldHVybiBbc2Nyb2xsQm91bmRzLm1heF07XG4gICAgaWYgKGNvbnRhaW5TY3JvbGwgPT09ICdrZWVwU25hcHMnKSByZXR1cm4gc25hcHNCb3VuZGVkO1xuICAgIGNvbnN0IHtcbiAgICAgIG1pbixcbiAgICAgIG1heFxuICAgIH0gPSBzY3JvbGxDb250YWluTGltaXQ7XG4gICAgcmV0dXJuIHNuYXBzQm91bmRlZC5zbGljZShtaW4sIG1heCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbmFwc0NvbnRhaW5lZCxcbiAgICBzY3JvbGxDb250YWluTGltaXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbExpbWl0KGNvbnRlbnRTaXplLCBzY3JvbGxTbmFwcywgbG9vcCkge1xuICBjb25zdCBtYXggPSBzY3JvbGxTbmFwc1swXTtcbiAgY29uc3QgbWluID0gbG9vcCA/IG1heCAtIGNvbnRlbnRTaXplIDogYXJyYXlMYXN0KHNjcm9sbFNuYXBzKTtcbiAgY29uc3QgbGltaXQgPSBMaW1pdChtaW4sIG1heCk7XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbGltaXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbExvb3Blcihjb250ZW50U2l6ZSwgbGltaXQsIG9mZnNldExvY2F0aW9uLCB2ZWN0b3JzKSB7XG4gIGNvbnN0IGpvaW50U2FmZXR5ID0gMC4xO1xuICBjb25zdCBtaW4gPSBsaW1pdC5taW4gKyBqb2ludFNhZmV0eTtcbiAgY29uc3QgbWF4ID0gbGltaXQubWF4ICsgam9pbnRTYWZldHk7XG4gIGNvbnN0IHtcbiAgICByZWFjaGVkTWluLFxuICAgIHJlYWNoZWRNYXhcbiAgfSA9IExpbWl0KG1pbiwgbWF4KTtcbiAgZnVuY3Rpb24gc2hvdWxkTG9vcChkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAxKSByZXR1cm4gcmVhY2hlZE1heChvZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHJldHVybiByZWFjaGVkTWluKG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcChkaXJlY3Rpb24pIHtcbiAgICBpZiAoIXNob3VsZExvb3AoZGlyZWN0aW9uKSkgcmV0dXJuO1xuICAgIGNvbnN0IGxvb3BEaXN0YW5jZSA9IGNvbnRlbnRTaXplICogKGRpcmVjdGlvbiAqIC0xKTtcbiAgICB2ZWN0b3JzLmZvckVhY2godiA9PiB2LmFkZChsb29wRGlzdGFuY2UpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGxvb3BcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFByb2dyZXNzKGxpbWl0KSB7XG4gIGNvbnN0IHtcbiAgICBtYXgsXG4gICAgbGVuZ3RoXG4gIH0gPSBsaW1pdDtcbiAgZnVuY3Rpb24gZ2V0KG4pIHtcbiAgICBjb25zdCBjdXJyZW50TG9jYXRpb24gPSBuIC0gbWF4O1xuICAgIHJldHVybiBsZW5ndGggPyBjdXJyZW50TG9jYXRpb24gLyAtbGVuZ3RoIDogMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGdldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsU25hcHMoYXhpcywgYWxpZ25tZW50LCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXNUb1Njcm9sbCkge1xuICBjb25zdCB7XG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2VcbiAgfSA9IGF4aXM7XG4gIGNvbnN0IHtcbiAgICBncm91cFNsaWRlc1xuICB9ID0gc2xpZGVzVG9TY3JvbGw7XG4gIGNvbnN0IGFsaWdubWVudHMgPSBtZWFzdXJlU2l6ZXMoKS5tYXAoYWxpZ25tZW50Lm1lYXN1cmUpO1xuICBjb25zdCBzbmFwcyA9IG1lYXN1cmVVbmFsaWduZWQoKTtcbiAgY29uc3Qgc25hcHNBbGlnbmVkID0gbWVhc3VyZUFsaWduZWQoKTtcbiAgZnVuY3Rpb24gbWVhc3VyZVNpemVzKCkge1xuICAgIHJldHVybiBncm91cFNsaWRlcyhzbGlkZVJlY3RzKS5tYXAocmVjdHMgPT4gYXJyYXlMYXN0KHJlY3RzKVtlbmRFZGdlXSAtIHJlY3RzWzBdW3N0YXJ0RWRnZV0pLm1hcChtYXRoQWJzKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlVW5hbGlnbmVkKCkge1xuICAgIHJldHVybiBzbGlkZVJlY3RzLm1hcChyZWN0ID0+IGNvbnRhaW5lclJlY3Rbc3RhcnRFZGdlXSAtIHJlY3Rbc3RhcnRFZGdlXSkubWFwKHNuYXAgPT4gLW1hdGhBYnMoc25hcCkpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVBbGlnbmVkKCkge1xuICAgIHJldHVybiBncm91cFNsaWRlcyhzbmFwcykubWFwKGcgPT4gZ1swXSkubWFwKChzbmFwLCBpbmRleCkgPT4gc25hcCArIGFsaWdubWVudHNbaW5kZXhdKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNuYXBzLFxuICAgIHNuYXBzQWxpZ25lZFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVSZWdpc3RyeShjb250YWluU25hcHMsIGNvbnRhaW5TY3JvbGwsIHNjcm9sbFNuYXBzLCBzY3JvbGxDb250YWluTGltaXQsIHNsaWRlc1RvU2Nyb2xsLCBzbGlkZUluZGV4ZXMpIHtcbiAgY29uc3Qge1xuICAgIGdyb3VwU2xpZGVzXG4gIH0gPSBzbGlkZXNUb1Njcm9sbDtcbiAgY29uc3Qge1xuICAgIG1pbixcbiAgICBtYXhcbiAgfSA9IHNjcm9sbENvbnRhaW5MaW1pdDtcbiAgY29uc3Qgc2xpZGVSZWdpc3RyeSA9IGNyZWF0ZVNsaWRlUmVnaXN0cnkoKTtcbiAgZnVuY3Rpb24gY3JlYXRlU2xpZGVSZWdpc3RyeSgpIHtcbiAgICBjb25zdCBncm91cGVkU2xpZGVJbmRleGVzID0gZ3JvdXBTbGlkZXMoc2xpZGVJbmRleGVzKTtcbiAgICBjb25zdCBkb05vdENvbnRhaW4gPSAhY29udGFpblNuYXBzIHx8IGNvbnRhaW5TY3JvbGwgPT09ICdrZWVwU25hcHMnO1xuICAgIGlmIChzY3JvbGxTbmFwcy5sZW5ndGggPT09IDEpIHJldHVybiBbc2xpZGVJbmRleGVzXTtcbiAgICBpZiAoZG9Ob3RDb250YWluKSByZXR1cm4gZ3JvdXBlZFNsaWRlSW5kZXhlcztcbiAgICByZXR1cm4gZ3JvdXBlZFNsaWRlSW5kZXhlcy5zbGljZShtaW4sIG1heCkubWFwKChncm91cCwgaW5kZXgsIGdyb3VwcykgPT4ge1xuICAgICAgY29uc3QgaXNGaXJzdCA9ICFpbmRleDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IGFycmF5SXNMYXN0SW5kZXgoZ3JvdXBzLCBpbmRleCk7XG4gICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGFycmF5TGFzdChncm91cHNbMF0pICsgMTtcbiAgICAgICAgcmV0dXJuIGFycmF5RnJvbU51bWJlcihyYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gYXJyYXlMYXN0SW5kZXgoc2xpZGVJbmRleGVzKSAtIGFycmF5TGFzdChncm91cHMpWzBdICsgMTtcbiAgICAgICAgcmV0dXJuIGFycmF5RnJvbU51bWJlcihyYW5nZSwgYXJyYXlMYXN0KGdyb3VwcylbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2xpZGVSZWdpc3RyeVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsVGFyZ2V0KGxvb3AsIHNjcm9sbFNuYXBzLCBjb250ZW50U2l6ZSwgbGltaXQsIHRhcmdldFZlY3Rvcikge1xuICBjb25zdCB7XG4gICAgcmVhY2hlZEFueSxcbiAgICByZW1vdmVPZmZzZXQsXG4gICAgY29uc3RyYWluXG4gIH0gPSBsaW1pdDtcbiAgZnVuY3Rpb24gbWluRGlzdGFuY2UoZGlzdGFuY2VzKSB7XG4gICAgcmV0dXJuIGRpc3RhbmNlcy5jb25jYXQoKS5zb3J0KChhLCBiKSA9PiBtYXRoQWJzKGEpIC0gbWF0aEFicyhiKSlbMF07XG4gIH1cbiAgZnVuY3Rpb24gZmluZFRhcmdldFNuYXAodGFyZ2V0KSB7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBsb29wID8gcmVtb3ZlT2Zmc2V0KHRhcmdldCkgOiBjb25zdHJhaW4odGFyZ2V0KTtcbiAgICBjb25zdCBhc2NEaWZmc1RvU25hcHMgPSBzY3JvbGxTbmFwcy5tYXAoc2Nyb2xsU25hcCA9PiBzY3JvbGxTbmFwIC0gZGlzdGFuY2UpLm1hcChkaWZmVG9TbmFwID0+IHNob3J0Y3V0KGRpZmZUb1NuYXAsIDApKS5tYXAoKGRpZmYsIGkpID0+ICh7XG4gICAgICBkaWZmLFxuICAgICAgaW5kZXg6IGlcbiAgICB9KSkuc29ydCgoZDEsIGQyKSA9PiBtYXRoQWJzKGQxLmRpZmYpIC0gbWF0aEFicyhkMi5kaWZmKSk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXhcbiAgICB9ID0gYXNjRGlmZnNUb1NuYXBzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzaG9ydGN1dCh0YXJnZXQsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldHMgPSBbdGFyZ2V0LCB0YXJnZXQgKyBjb250ZW50U2l6ZSwgdGFyZ2V0IC0gY29udGVudFNpemVdO1xuICAgIGlmICghbG9vcCkgcmV0dXJuIHRhcmdldHNbMF07XG4gICAgaWYgKCFkaXJlY3Rpb24pIHJldHVybiBtaW5EaXN0YW5jZSh0YXJnZXRzKTtcbiAgICBjb25zdCBtYXRjaGluZ1RhcmdldHMgPSB0YXJnZXRzLmZpbHRlcih0ID0+IG1hdGhTaWduKHQpID09PSBkaXJlY3Rpb24pO1xuICAgIGlmIChtYXRjaGluZ1RhcmdldHMubGVuZ3RoKSByZXR1cm4gbWluRGlzdGFuY2UobWF0Y2hpbmdUYXJnZXRzKTtcbiAgICByZXR1cm4gYXJyYXlMYXN0KHRhcmdldHMpIC0gY29udGVudFNpemU7XG4gIH1cbiAgZnVuY3Rpb24gYnlJbmRleChpbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgZGlmZlRvU25hcCA9IHNjcm9sbFNuYXBzW2luZGV4XSAtIHRhcmdldFZlY3Rvci5nZXQoKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHNob3J0Y3V0KGRpZmZUb1NuYXAsIGRpcmVjdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ5RGlzdGFuY2UoZGlzdGFuY2UsIHNuYXApIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRWZWN0b3IuZ2V0KCkgKyBkaXN0YW5jZTtcbiAgICBjb25zdCB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlOiB0YXJnZXRTbmFwRGlzdGFuY2VcbiAgICB9ID0gZmluZFRhcmdldFNuYXAodGFyZ2V0KTtcbiAgICBjb25zdCByZWFjaGVkQm91bmQgPSAhbG9vcCAmJiByZWFjaGVkQW55KHRhcmdldCk7XG4gICAgaWYgKCFzbmFwIHx8IHJlYWNoZWRCb3VuZCkgcmV0dXJuIHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuICAgIGNvbnN0IGRpZmZUb1NuYXAgPSBzY3JvbGxTbmFwc1tpbmRleF0gLSB0YXJnZXRTbmFwRGlzdGFuY2U7XG4gICAgY29uc3Qgc25hcERpc3RhbmNlID0gZGlzdGFuY2UgKyBzaG9ydGN1dChkaWZmVG9TbmFwLCAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZTogc25hcERpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGJ5RGlzdGFuY2UsXG4gICAgYnlJbmRleCxcbiAgICBzaG9ydGN1dFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsVG8oYW5pbWF0aW9uLCBpbmRleEN1cnJlbnQsIGluZGV4UHJldmlvdXMsIHNjcm9sbFRhcmdldCwgdGFyZ2V0VmVjdG9yLCBldmVudEhhbmRsZXIpIHtcbiAgZnVuY3Rpb24gc2Nyb2xsVG8odGFyZ2V0KSB7XG4gICAgY29uc3QgZGlzdGFuY2VEaWZmID0gdGFyZ2V0LmRpc3RhbmNlO1xuICAgIGNvbnN0IGluZGV4RGlmZiA9IHRhcmdldC5pbmRleCAhPT0gaW5kZXhDdXJyZW50LmdldCgpO1xuICAgIHRhcmdldFZlY3Rvci5hZGQoZGlzdGFuY2VEaWZmKTtcbiAgICBpZiAoZGlzdGFuY2VEaWZmKSBhbmltYXRpb24uc3RhcnQoKTtcbiAgICBpZiAoaW5kZXhEaWZmKSB7XG4gICAgICBpbmRleFByZXZpb3VzLnNldChpbmRleEN1cnJlbnQuZ2V0KCkpO1xuICAgICAgaW5kZXhDdXJyZW50LnNldCh0YXJnZXQuaW5kZXgpO1xuICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NlbGVjdCcpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXN0YW5jZShuLCBzbmFwKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0LmJ5RGlzdGFuY2Uobiwgc25hcCk7XG4gICAgc2Nyb2xsVG8odGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBpbmRleChuLCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IGluZGV4Q3VycmVudC5jbG9uZSgpLnNldChuKTtcbiAgICBjb25zdCB0YXJnZXQgPSBzY3JvbGxUYXJnZXQuYnlJbmRleCh0YXJnZXRJbmRleC5nZXQoKSwgZGlyZWN0aW9uKTtcbiAgICBzY3JvbGxUbyh0YXJnZXQpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZGlzdGFuY2UsXG4gICAgaW5kZXhcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlRm9jdXMocm9vdCwgc2xpZGVzLCBzbGlkZVJlZ2lzdHJ5LCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgZXZlbnRTdG9yZSkge1xuICBsZXQgbGFzdFRhYlByZXNzVGltZSA9IDA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgZXZlbnRTdG9yZS5hZGQoZG9jdW1lbnQsICdrZXlkb3duJywgcmVnaXN0ZXJUYWJQcmVzcywgZmFsc2UpO1xuICAgIHNsaWRlcy5mb3JFYWNoKGFkZFNsaWRlRm9jdXNFdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJUYWJQcmVzcyhldmVudCkge1xuICAgIGlmIChldmVudC5jb2RlID09PSAnVGFiJykgbGFzdFRhYlByZXNzVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFNsaWRlRm9jdXNFdmVudChzbGlkZSkge1xuICAgIGNvbnN0IGZvY3VzID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm93VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgZGlmZlRpbWUgPSBub3dUaW1lIC0gbGFzdFRhYlByZXNzVGltZTtcbiAgICAgIGlmIChkaWZmVGltZSA+IDEwKSByZXR1cm47XG4gICAgICByb290LnNjcm9sbExlZnQgPSAwO1xuICAgICAgY29uc3QgaW5kZXggPSBzbGlkZXMuaW5kZXhPZihzbGlkZSk7XG4gICAgICBjb25zdCBncm91cCA9IHNsaWRlUmVnaXN0cnkuZmluZEluZGV4KGdyb3VwID0+IGdyb3VwLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICBpZiAoIWlzTnVtYmVyKGdyb3VwKSkgcmV0dXJuO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigwKTtcbiAgICAgIHNjcm9sbFRvLmluZGV4KGdyb3VwLCAwKTtcbiAgICB9O1xuICAgIGV2ZW50U3RvcmUuYWRkKHNsaWRlLCAnZm9jdXMnLCBmb2N1cywge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXRcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFZlY3RvcjFEKGluaXRpYWxWYWx1ZSkge1xuICBsZXQgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gc2V0KG4pIHtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChuKSB7XG4gICAgdmFsdWUgKz0gbm9ybWFsaXplSW5wdXQobik7XG4gIH1cbiAgZnVuY3Rpb24gc3VidHJhY3Qobikge1xuICAgIHZhbHVlIC09IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUlucHV0KG4pIHtcbiAgICByZXR1cm4gaXNOdW1iZXIobikgPyBuIDogbi5nZXQoKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgYWRkLFxuICAgIHN1YnRyYWN0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBUcmFuc2xhdGUoYXhpcywgZGlyZWN0aW9uLCBjb250YWluZXIpIHtcbiAgY29uc3QgdHJhbnNsYXRlID0gYXhpcy5zY3JvbGwgPT09ICd4JyA/IHggOiB5O1xuICBjb25zdCBjb250YWluZXJTdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHgobikge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHtufXB4LDBweCwwcHgpYDtcbiAgfVxuICBmdW5jdGlvbiB5KG4pIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZTNkKDBweCwke259cHgsMHB4KWA7XG4gIH1cbiAgZnVuY3Rpb24gdG8odGFyZ2V0KSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtID0gdHJhbnNsYXRlKGRpcmVjdGlvbi5hcHBseSh0YXJnZXQpKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVBY3RpdmUoYWN0aXZlKSB7XG4gICAgZGlzYWJsZWQgPSAhYWN0aXZlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgIGlmICghY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNsZWFyLFxuICAgIHRvLFxuICAgIHRvZ2dsZUFjdGl2ZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVMb29wZXIoYXhpcywgZGlyZWN0aW9uLCB2aWV3U2l6ZSwgY29udGVudFNpemUsIHNsaWRlU2l6ZXMsIHNsaWRlU2l6ZXNXaXRoR2Fwcywgc25hcHMsIHNjcm9sbFNuYXBzLCBvZmZzZXRMb2NhdGlvbiwgc2xpZGVzKSB7XG4gIGNvbnN0IHJvdW5kaW5nU2FmZXR5ID0gMC41O1xuICBjb25zdCBhc2NJdGVtcyA9IGFycmF5S2V5cyhzbGlkZVNpemVzV2l0aEdhcHMpO1xuICBjb25zdCBkZXNjSXRlbXMgPSBhcnJheUtleXMoc2xpZGVTaXplc1dpdGhHYXBzKS5yZXZlcnNlKCk7XG4gIGNvbnN0IGxvb3BQb2ludHMgPSBzdGFydFBvaW50cygpLmNvbmNhdChlbmRQb2ludHMoKSk7XG4gIGZ1bmN0aW9uIHJlbW92ZVNsaWRlU2l6ZXMoaW5kZXhlcywgZnJvbSkge1xuICAgIHJldHVybiBpbmRleGVzLnJlZHVjZSgoYSwgaSkgPT4ge1xuICAgICAgcmV0dXJuIGEgLSBzbGlkZVNpemVzV2l0aEdhcHNbaV07XG4gICAgfSwgZnJvbSk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzSW5HYXAoaW5kZXhlcywgZ2FwKSB7XG4gICAgcmV0dXJuIGluZGV4ZXMucmVkdWNlKChhLCBpKSA9PiB7XG4gICAgICBjb25zdCByZW1haW5pbmdHYXAgPSByZW1vdmVTbGlkZVNpemVzKGEsIGdhcCk7XG4gICAgICByZXR1cm4gcmVtYWluaW5nR2FwID4gMCA/IGEuY29uY2F0KFtpXSkgOiBhO1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kU2xpZGVCb3VuZHMob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHNuYXBzLm1hcCgoc25hcCwgaW5kZXgpID0+ICh7XG4gICAgICBzdGFydDogc25hcCAtIHNsaWRlU2l6ZXNbaW5kZXhdICsgcm91bmRpbmdTYWZldHkgKyBvZmZzZXQsXG4gICAgICBlbmQ6IHNuYXAgKyB2aWV3U2l6ZSAtIHJvdW5kaW5nU2FmZXR5ICsgb2Zmc2V0XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIG9mZnNldCwgaXNFbmRFZGdlKSB7XG4gICAgY29uc3Qgc2xpZGVCb3VuZHMgPSBmaW5kU2xpZGVCb3VuZHMob2Zmc2V0KTtcbiAgICByZXR1cm4gaW5kZXhlcy5tYXAoaW5kZXggPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbCA9IGlzRW5kRWRnZSA/IDAgOiAtY29udGVudFNpemU7XG4gICAgICBjb25zdCBhbHRlcmVkID0gaXNFbmRFZGdlID8gY29udGVudFNpemUgOiAwO1xuICAgICAgY29uc3QgYm91bmRFZGdlID0gaXNFbmRFZGdlID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgY29uc3QgbG9vcFBvaW50ID0gc2xpZGVCb3VuZHNbaW5kZXhdW2JvdW5kRWRnZV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleCxcbiAgICAgICAgbG9vcFBvaW50LFxuICAgICAgICBzbGlkZUxvY2F0aW9uOiBWZWN0b3IxRCgtMSksXG4gICAgICAgIHRyYW5zbGF0ZTogVHJhbnNsYXRlKGF4aXMsIGRpcmVjdGlvbiwgc2xpZGVzW2luZGV4XSksXG4gICAgICAgIHRhcmdldDogKCkgPT4gb2Zmc2V0TG9jYXRpb24uZ2V0KCkgPiBsb29wUG9pbnQgPyBpbml0aWFsIDogYWx0ZXJlZFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydFBvaW50cygpIHtcbiAgICBjb25zdCBnYXAgPSBzY3JvbGxTbmFwc1swXTtcbiAgICBjb25zdCBpbmRleGVzID0gc2xpZGVzSW5HYXAoZGVzY0l0ZW1zLCBnYXApO1xuICAgIHJldHVybiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCBjb250ZW50U2l6ZSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGVuZFBvaW50cygpIHtcbiAgICBjb25zdCBnYXAgPSB2aWV3U2l6ZSAtIHNjcm9sbFNuYXBzWzBdIC0gMTtcbiAgICBjb25zdCBpbmRleGVzID0gc2xpZGVzSW5HYXAoYXNjSXRlbXMsIGdhcCk7XG4gICAgcmV0dXJuIGZpbmRMb29wUG9pbnRzKGluZGV4ZXMsIC1jb250ZW50U2l6ZSwgdHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuTG9vcCgpIHtcbiAgICByZXR1cm4gbG9vcFBvaW50cy5ldmVyeSgoe1xuICAgICAgaW5kZXhcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBvdGhlckluZGV4ZXMgPSBhc2NJdGVtcy5maWx0ZXIoaSA9PiBpICE9PSBpbmRleCk7XG4gICAgICByZXR1cm4gcmVtb3ZlU2xpZGVTaXplcyhvdGhlckluZGV4ZXMsIHZpZXdTaXplKSA8PSAwLjE7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcCgpIHtcbiAgICBsb29wUG9pbnRzLmZvckVhY2gobG9vcFBvaW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0cmFuc2xhdGUsXG4gICAgICAgIHNsaWRlTG9jYXRpb25cbiAgICAgIH0gPSBsb29wUG9pbnQ7XG4gICAgICBjb25zdCBzaGlmdExvY2F0aW9uID0gdGFyZ2V0KCk7XG4gICAgICBpZiAoc2hpZnRMb2NhdGlvbiA9PT0gc2xpZGVMb2NhdGlvbi5nZXQoKSkgcmV0dXJuO1xuICAgICAgdHJhbnNsYXRlLnRvKHNoaWZ0TG9jYXRpb24pO1xuICAgICAgc2xpZGVMb2NhdGlvbi5zZXQoc2hpZnRMb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgbG9vcFBvaW50cy5mb3JFYWNoKGxvb3BQb2ludCA9PiBsb29wUG9pbnQudHJhbnNsYXRlLmNsZWFyKCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgY2FuTG9vcCxcbiAgICBjbGVhcixcbiAgICBsb29wLFxuICAgIGxvb3BQb2ludHNcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc0hhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIHdhdGNoU2xpZGVzKSB7XG4gIGxldCBtdXRhdGlvbk9ic2VydmVyO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGkpIHtcbiAgICBpZiAoIXdhdGNoU2xpZGVzKSByZXR1cm47XG4gICAgZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKG11dGF0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgZW1ibGFBcGkucmVJbml0KCk7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NsaWRlc0NoYW5nZWQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgIGlmIChpc0Jvb2xlYW4od2F0Y2hTbGlkZXMpIHx8IHdhdGNoU2xpZGVzKGVtYmxhQXBpLCBtdXRhdGlvbnMpKSB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjayhtdXRhdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXIpIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlc0luVmlldyhjb250YWluZXIsIHNsaWRlcywgZXZlbnRIYW5kbGVyLCB0aHJlc2hvbGQpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uRW50cnlNYXAgPSB7fTtcbiAgbGV0IGluVmlld0NhY2hlID0gbnVsbDtcbiAgbGV0IG5vdEluVmlld0NhY2hlID0gbnVsbDtcbiAgbGV0IGludGVyc2VjdGlvbk9ic2VydmVyO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHNsaWRlcy5pbmRleE9mKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIGludGVyc2VjdGlvbkVudHJ5TWFwW2luZGV4XSA9IGVudHJ5O1xuICAgICAgfSk7XG4gICAgICBpblZpZXdDYWNoZSA9IG51bGw7XG4gICAgICBub3RJblZpZXdDYWNoZSA9IG51bGw7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2xpZGVzSW5WaWV3Jyk7XG4gICAgfSwge1xuICAgICAgcm9vdDogY29udGFpbmVyLnBhcmVudEVsZW1lbnQsXG4gICAgICB0aHJlc2hvbGRcbiAgICB9KTtcbiAgICBzbGlkZXMuZm9yRWFjaChzbGlkZSA9PiBpbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHNsaWRlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIGludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluVmlld0xpc3QoaW5WaWV3KSB7XG4gICAgcmV0dXJuIG9iamVjdEtleXMoaW50ZXJzZWN0aW9uRW50cnlNYXApLnJlZHVjZSgobGlzdCwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChzbGlkZUluZGV4KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNJbnRlcnNlY3RpbmdcbiAgICAgIH0gPSBpbnRlcnNlY3Rpb25FbnRyeU1hcFtpbmRleF07XG4gICAgICBjb25zdCBpblZpZXdNYXRjaCA9IGluVmlldyAmJiBpc0ludGVyc2VjdGluZztcbiAgICAgIGNvbnN0IG5vdEluVmlld01hdGNoID0gIWluVmlldyAmJiAhaXNJbnRlcnNlY3Rpbmc7XG4gICAgICBpZiAoaW5WaWV3TWF0Y2ggfHwgbm90SW5WaWV3TWF0Y2gpIGxpc3QucHVzaChpbmRleCk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KGluVmlldyA9IHRydWUpIHtcbiAgICBpZiAoaW5WaWV3ICYmIGluVmlld0NhY2hlKSByZXR1cm4gaW5WaWV3Q2FjaGU7XG4gICAgaWYgKCFpblZpZXcgJiYgbm90SW5WaWV3Q2FjaGUpIHJldHVybiBub3RJblZpZXdDYWNoZTtcbiAgICBjb25zdCBzbGlkZUluZGV4ZXMgPSBjcmVhdGVJblZpZXdMaXN0KGluVmlldyk7XG4gICAgaWYgKGluVmlldykgaW5WaWV3Q2FjaGUgPSBzbGlkZUluZGV4ZXM7XG4gICAgaWYgKCFpblZpZXcpIG5vdEluVmlld0NhY2hlID0gc2xpZGVJbmRleGVzO1xuICAgIHJldHVybiBzbGlkZUluZGV4ZXM7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgZ2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZVNpemVzKGF4aXMsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlcywgcmVhZEVkZ2VHYXAsIG93bmVyV2luZG93KSB7XG4gIGNvbnN0IHtcbiAgICBtZWFzdXJlU2l6ZSxcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3Qgd2l0aEVkZ2VHYXAgPSBzbGlkZVJlY3RzWzBdICYmIHJlYWRFZGdlR2FwO1xuICBjb25zdCBzdGFydEdhcCA9IG1lYXN1cmVTdGFydEdhcCgpO1xuICBjb25zdCBlbmRHYXAgPSBtZWFzdXJlRW5kR2FwKCk7XG4gIGNvbnN0IHNsaWRlU2l6ZXMgPSBzbGlkZVJlY3RzLm1hcChtZWFzdXJlU2l6ZSk7XG4gIGNvbnN0IHNsaWRlU2l6ZXNXaXRoR2FwcyA9IG1lYXN1cmVXaXRoR2FwcygpO1xuICBmdW5jdGlvbiBtZWFzdXJlU3RhcnRHYXAoKSB7XG4gICAgaWYgKCF3aXRoRWRnZUdhcCkgcmV0dXJuIDA7XG4gICAgY29uc3Qgc2xpZGVSZWN0ID0gc2xpZGVSZWN0c1swXTtcbiAgICByZXR1cm4gbWF0aEFicyhjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3Rbc3RhcnRFZGdlXSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUVuZEdhcCgpIHtcbiAgICBpZiAoIXdpdGhFZGdlR2FwKSByZXR1cm4gMDtcbiAgICBjb25zdCBzdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoYXJyYXlMYXN0KHNsaWRlcykpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoYG1hcmdpbi0ke2VuZEVkZ2V9YCkpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVXaXRoR2FwcygpIHtcbiAgICByZXR1cm4gc2xpZGVSZWN0cy5tYXAoKHJlY3QsIGluZGV4LCByZWN0cykgPT4ge1xuICAgICAgY29uc3QgaXNGaXJzdCA9ICFpbmRleDtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IGFycmF5SXNMYXN0SW5kZXgocmVjdHMsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gc2xpZGVTaXplc1tpbmRleF0gKyBzdGFydEdhcDtcbiAgICAgIGlmIChpc0xhc3QpIHJldHVybiBzbGlkZVNpemVzW2luZGV4XSArIGVuZEdhcDtcbiAgICAgIHJldHVybiByZWN0c1tpbmRleCArIDFdW3N0YXJ0RWRnZV0gLSByZWN0W3N0YXJ0RWRnZV07XG4gICAgfSkubWFwKG1hdGhBYnMpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc2xpZGVTaXplcyxcbiAgICBzbGlkZVNpemVzV2l0aEdhcHMsXG4gICAgc3RhcnRHYXAsXG4gICAgZW5kR2FwXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNUb1Njcm9sbChheGlzLCBkaXJlY3Rpb24sIHZpZXdTaXplLCBzbGlkZXNUb1Njcm9sbCwgbG9vcCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc3RhcnRHYXAsIGVuZEdhcCwgcGl4ZWxUb2xlcmFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RWRnZSxcbiAgICBlbmRFZGdlXG4gIH0gPSBheGlzO1xuICBjb25zdCBncm91cEJ5TnVtYmVyID0gaXNOdW1iZXIoc2xpZGVzVG9TY3JvbGwpO1xuICBmdW5jdGlvbiBieU51bWJlcihhcnJheSwgZ3JvdXBTaXplKSB7XG4gICAgcmV0dXJuIGFycmF5S2V5cyhhcnJheSkuZmlsdGVyKGkgPT4gaSAlIGdyb3VwU2l6ZSA9PT0gMCkubWFwKGkgPT4gYXJyYXkuc2xpY2UoaSwgaSArIGdyb3VwU2l6ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGJ5U2l6ZShhcnJheSkge1xuICAgIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFycmF5S2V5cyhhcnJheSkucmVkdWNlKChncm91cHMsIHJlY3RCKSA9PiB7XG4gICAgICBjb25zdCByZWN0QSA9IGFycmF5TGFzdChncm91cHMpIHx8IDA7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gcmVjdEEgPT09IDA7XG4gICAgICBjb25zdCBpc0xhc3QgPSByZWN0QiA9PT0gYXJyYXlMYXN0SW5kZXgoYXJyYXkpO1xuICAgICAgY29uc3QgZWRnZUEgPSBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3RzW3JlY3RBXVtzdGFydEVkZ2VdO1xuICAgICAgY29uc3QgZWRnZUIgPSBjb250YWluZXJSZWN0W3N0YXJ0RWRnZV0gLSBzbGlkZVJlY3RzW3JlY3RCXVtlbmRFZGdlXTtcbiAgICAgIGNvbnN0IGdhcEEgPSAhbG9vcCAmJiBpc0ZpcnN0ID8gZGlyZWN0aW9uLmFwcGx5KHN0YXJ0R2FwKSA6IDA7XG4gICAgICBjb25zdCBnYXBCID0gIWxvb3AgJiYgaXNMYXN0ID8gZGlyZWN0aW9uLmFwcGx5KGVuZEdhcCkgOiAwO1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gbWF0aEFicyhlZGdlQiAtIGdhcEIgLSAoZWRnZUEgKyBnYXBBKSk7XG4gICAgICBpZiAoY2h1bmtTaXplID4gdmlld1NpemUgKyBwaXhlbFRvbGVyYW5jZSkgZ3JvdXBzLnB1c2gocmVjdEIpO1xuICAgICAgaWYgKGlzTGFzdCkgZ3JvdXBzLnB1c2goYXJyYXkubGVuZ3RoKTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSwgW10pLm1hcCgoY3VycmVudFNpemUsIGluZGV4LCBncm91cHMpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2l6ZSA9IE1hdGgubWF4KGdyb3Vwc1tpbmRleCAtIDFdIHx8IDApO1xuICAgICAgcmV0dXJuIGFycmF5LnNsaWNlKHByZXZpb3VzU2l6ZSwgY3VycmVudFNpemUpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdyb3VwU2xpZGVzKGFycmF5KSB7XG4gICAgcmV0dXJuIGdyb3VwQnlOdW1iZXIgPyBieU51bWJlcihhcnJheSwgc2xpZGVzVG9TY3JvbGwpIDogYnlTaXplKGFycmF5KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGdyb3VwU2xpZGVzXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFbmdpbmUocm9vdCwgY29udGFpbmVyLCBzbGlkZXMsIG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCBvcHRpb25zLCBldmVudEhhbmRsZXIsIGFuaW1hdGlvbnMpIHtcbiAgLy8gT3B0aW9uc1xuICBjb25zdCB7XG4gICAgYWxpZ24sXG4gICAgYXhpczogc2Nyb2xsQXhpcyxcbiAgICBkaXJlY3Rpb246IGNvbnRlbnREaXJlY3Rpb24sXG4gICAgc3RhcnRJbmRleCxcbiAgICBsb29wLFxuICAgIGR1cmF0aW9uLFxuICAgIGRyYWdGcmVlLFxuICAgIGRyYWdUaHJlc2hvbGQsXG4gICAgaW5WaWV3VGhyZXNob2xkLFxuICAgIHNsaWRlc1RvU2Nyb2xsOiBncm91cFNsaWRlcyxcbiAgICBza2lwU25hcHMsXG4gICAgY29udGFpblNjcm9sbCxcbiAgICB3YXRjaFJlc2l6ZSxcbiAgICB3YXRjaFNsaWRlcyxcbiAgICB3YXRjaERyYWdcbiAgfSA9IG9wdGlvbnM7XG4gIC8vIE1lYXN1cmVtZW50c1xuICBjb25zdCBwaXhlbFRvbGVyYW5jZSA9IDI7XG4gIGNvbnN0IG5vZGVSZWN0cyA9IE5vZGVSZWN0cygpO1xuICBjb25zdCBjb250YWluZXJSZWN0ID0gbm9kZVJlY3RzLm1lYXN1cmUoY29udGFpbmVyKTtcbiAgY29uc3Qgc2xpZGVSZWN0cyA9IHNsaWRlcy5tYXAobm9kZVJlY3RzLm1lYXN1cmUpO1xuICBjb25zdCBkaXJlY3Rpb24gPSBEaXJlY3Rpb24oY29udGVudERpcmVjdGlvbik7XG4gIGNvbnN0IGF4aXMgPSBBeGlzKHNjcm9sbEF4aXMsIGNvbnRlbnREaXJlY3Rpb24pO1xuICBjb25zdCB2aWV3U2l6ZSA9IGF4aXMubWVhc3VyZVNpemUoY29udGFpbmVyUmVjdCk7XG4gIGNvbnN0IHBlcmNlbnRPZlZpZXcgPSBQZXJjZW50T2ZWaWV3KHZpZXdTaXplKTtcbiAgY29uc3QgYWxpZ25tZW50ID0gQWxpZ25tZW50KGFsaWduLCB2aWV3U2l6ZSk7XG4gIGNvbnN0IGNvbnRhaW5TbmFwcyA9ICFsb29wICYmICEhY29udGFpblNjcm9sbDtcbiAgY29uc3QgcmVhZEVkZ2VHYXAgPSBsb29wIHx8ICEhY29udGFpblNjcm9sbDtcbiAgY29uc3Qge1xuICAgIHNsaWRlU2l6ZXMsXG4gICAgc2xpZGVTaXplc1dpdGhHYXBzLFxuICAgIHN0YXJ0R2FwLFxuICAgIGVuZEdhcFxuICB9ID0gU2xpZGVTaXplcyhheGlzLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXMsIHJlYWRFZGdlR2FwLCBvd25lcldpbmRvdyk7XG4gIGNvbnN0IHNsaWRlc1RvU2Nyb2xsID0gU2xpZGVzVG9TY3JvbGwoYXhpcywgZGlyZWN0aW9uLCB2aWV3U2l6ZSwgZ3JvdXBTbGlkZXMsIGxvb3AsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHN0YXJ0R2FwLCBlbmRHYXAsIHBpeGVsVG9sZXJhbmNlKTtcbiAgY29uc3Qge1xuICAgIHNuYXBzLFxuICAgIHNuYXBzQWxpZ25lZFxuICB9ID0gU2Nyb2xsU25hcHMoYXhpcywgYWxpZ25tZW50LCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXNUb1Njcm9sbCk7XG4gIGNvbnN0IGNvbnRlbnRTaXplID0gLWFycmF5TGFzdChzbmFwcykgKyBhcnJheUxhc3Qoc2xpZGVTaXplc1dpdGhHYXBzKTtcbiAgY29uc3Qge1xuICAgIHNuYXBzQ29udGFpbmVkLFxuICAgIHNjcm9sbENvbnRhaW5MaW1pdFxuICB9ID0gU2Nyb2xsQ29udGFpbih2aWV3U2l6ZSwgY29udGVudFNpemUsIHNuYXBzQWxpZ25lZCwgY29udGFpblNjcm9sbCwgcGl4ZWxUb2xlcmFuY2UpO1xuICBjb25zdCBzY3JvbGxTbmFwcyA9IGNvbnRhaW5TbmFwcyA/IHNuYXBzQ29udGFpbmVkIDogc25hcHNBbGlnbmVkO1xuICBjb25zdCB7XG4gICAgbGltaXRcbiAgfSA9IFNjcm9sbExpbWl0KGNvbnRlbnRTaXplLCBzY3JvbGxTbmFwcywgbG9vcCk7XG4gIC8vIEluZGV4ZXNcbiAgY29uc3QgaW5kZXggPSBDb3VudGVyKGFycmF5TGFzdEluZGV4KHNjcm9sbFNuYXBzKSwgc3RhcnRJbmRleCwgbG9vcCk7XG4gIGNvbnN0IGluZGV4UHJldmlvdXMgPSBpbmRleC5jbG9uZSgpO1xuICBjb25zdCBzbGlkZUluZGV4ZXMgPSBhcnJheUtleXMoc2xpZGVzKTtcbiAgLy8gQW5pbWF0aW9uXG4gIGNvbnN0IHVwZGF0ZSA9ICh7XG4gICAgZHJhZ0hhbmRsZXIsXG4gICAgc2Nyb2xsQm9keSxcbiAgICBzY3JvbGxCb3VuZHMsXG4gICAgb3B0aW9uczoge1xuICAgICAgbG9vcFxuICAgIH1cbiAgfSkgPT4ge1xuICAgIGlmICghbG9vcCkgc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihkcmFnSGFuZGxlci5wb2ludGVyRG93bigpKTtcbiAgICBzY3JvbGxCb2R5LnNlZWsoKTtcbiAgfTtcbiAgY29uc3QgcmVuZGVyID0gKHtcbiAgICBzY3JvbGxCb2R5LFxuICAgIHRyYW5zbGF0ZSxcbiAgICBsb2NhdGlvbixcbiAgICBvZmZzZXRMb2NhdGlvbixcbiAgICBzY3JvbGxMb29wZXIsXG4gICAgc2xpZGVMb29wZXIsXG4gICAgZHJhZ0hhbmRsZXIsXG4gICAgYW5pbWF0aW9uLFxuICAgIGV2ZW50SGFuZGxlcixcbiAgICBvcHRpb25zOiB7XG4gICAgICBsb29wXG4gICAgfVxuICB9LCBsYWdPZmZzZXQpID0+IHtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IHNjcm9sbEJvZHkudmVsb2NpdHkoKTtcbiAgICBjb25zdCBoYXNTZXR0bGVkID0gc2Nyb2xsQm9keS5zZXR0bGVkKCk7XG4gICAgaWYgKGhhc1NldHRsZWQgJiYgIWRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpIHtcbiAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICBldmVudEhhbmRsZXIuZW1pdCgnc2V0dGxlJyk7XG4gICAgfVxuICAgIGlmICghaGFzU2V0dGxlZCkgZXZlbnRIYW5kbGVyLmVtaXQoJ3Njcm9sbCcpO1xuICAgIG9mZnNldExvY2F0aW9uLnNldChsb2NhdGlvbi5nZXQoKSAtIHZlbG9jaXR5ICsgdmVsb2NpdHkgKiBsYWdPZmZzZXQpO1xuICAgIGlmIChsb29wKSB7XG4gICAgICBzY3JvbGxMb29wZXIubG9vcChzY3JvbGxCb2R5LmRpcmVjdGlvbigpKTtcbiAgICAgIHNsaWRlTG9vcGVyLmxvb3AoKTtcbiAgICB9XG4gICAgdHJhbnNsYXRlLnRvKG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgfTtcbiAgY29uc3QgYW5pbWF0aW9uID0ge1xuICAgIHN0YXJ0OiAoKSA9PiBhbmltYXRpb25zLnN0YXJ0KGVuZ2luZSksXG4gICAgc3RvcDogKCkgPT4gYW5pbWF0aW9ucy5zdG9wKGVuZ2luZSksXG4gICAgdXBkYXRlOiAoKSA9PiB1cGRhdGUoZW5naW5lKSxcbiAgICByZW5kZXI6IGxhZ09mZnNldCA9PiByZW5kZXIoZW5naW5lLCBsYWdPZmZzZXQpXG4gIH07XG4gIC8vIFNoYXJlZFxuICBjb25zdCBmcmljdGlvbiA9IDAuNjg7XG4gIGNvbnN0IHN0YXJ0TG9jYXRpb24gPSBzY3JvbGxTbmFwc1tpbmRleC5nZXQoKV07XG4gIGNvbnN0IGxvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IG9mZnNldExvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHRhcmdldCA9IFZlY3RvcjFEKHN0YXJ0TG9jYXRpb24pO1xuICBjb25zdCBzY3JvbGxCb2R5ID0gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgZHVyYXRpb24sIGZyaWN0aW9uKTtcbiAgY29uc3Qgc2Nyb2xsVGFyZ2V0ID0gU2Nyb2xsVGFyZ2V0KGxvb3AsIHNjcm9sbFNuYXBzLCBjb250ZW50U2l6ZSwgbGltaXQsIHRhcmdldCk7XG4gIGNvbnN0IHNjcm9sbFRvID0gU2Nyb2xsVG8oYW5pbWF0aW9uLCBpbmRleCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsVGFyZ2V0LCB0YXJnZXQsIGV2ZW50SGFuZGxlcik7XG4gIGNvbnN0IHNjcm9sbFByb2dyZXNzID0gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpO1xuICBjb25zdCBldmVudFN0b3JlID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCBzbGlkZXNJblZpZXcgPSBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgaW5WaWV3VGhyZXNob2xkKTtcbiAgY29uc3Qge1xuICAgIHNsaWRlUmVnaXN0cnlcbiAgfSA9IFNsaWRlUmVnaXN0cnkoY29udGFpblNuYXBzLCBjb250YWluU2Nyb2xsLCBzY3JvbGxTbmFwcywgc2Nyb2xsQ29udGFpbkxpbWl0LCBzbGlkZXNUb1Njcm9sbCwgc2xpZGVJbmRleGVzKTtcbiAgY29uc3Qgc2xpZGVGb2N1cyA9IFNsaWRlRm9jdXMocm9vdCwgc2xpZGVzLCBzbGlkZVJlZ2lzdHJ5LCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgZXZlbnRTdG9yZSk7XG4gIC8vIEVuZ2luZVxuICBjb25zdCBlbmdpbmUgPSB7XG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBvd25lcldpbmRvdyxcbiAgICBldmVudEhhbmRsZXIsXG4gICAgY29udGFpbmVyUmVjdCxcbiAgICBzbGlkZVJlY3RzLFxuICAgIGFuaW1hdGlvbixcbiAgICBheGlzLFxuICAgIGRpcmVjdGlvbixcbiAgICBkcmFnSGFuZGxlcjogRHJhZ0hhbmRsZXIoYXhpcywgZGlyZWN0aW9uLCByb290LCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgdGFyZ2V0LCBEcmFnVHJhY2tlcihheGlzLCBvd25lcldpbmRvdyksIGxvY2F0aW9uLCBhbmltYXRpb24sIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIGluZGV4LCBldmVudEhhbmRsZXIsIHBlcmNlbnRPZlZpZXcsIGRyYWdGcmVlLCBkcmFnVGhyZXNob2xkLCBza2lwU25hcHMsIGZyaWN0aW9uLCB3YXRjaERyYWcpLFxuICAgIGV2ZW50U3RvcmUsXG4gICAgcGVyY2VudE9mVmlldyxcbiAgICBpbmRleCxcbiAgICBpbmRleFByZXZpb3VzLFxuICAgIGxpbWl0LFxuICAgIGxvY2F0aW9uLFxuICAgIG9mZnNldExvY2F0aW9uLFxuICAgIG9wdGlvbnMsXG4gICAgcmVzaXplSGFuZGxlcjogUmVzaXplSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgb3duZXJXaW5kb3csIHNsaWRlcywgYXhpcywgd2F0Y2hSZXNpemUsIG5vZGVSZWN0cyksXG4gICAgc2Nyb2xsQm9keSxcbiAgICBzY3JvbGxCb3VuZHM6IFNjcm9sbEJvdW5kcyhsaW1pdCwgbG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldyksXG4gICAgc2Nyb2xsTG9vcGVyOiBTY3JvbGxMb29wZXIoY29udGVudFNpemUsIGxpbWl0LCBvZmZzZXRMb2NhdGlvbiwgW2xvY2F0aW9uLCBvZmZzZXRMb2NhdGlvbiwgdGFyZ2V0XSksXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3Q6IHNjcm9sbFNuYXBzLm1hcChzY3JvbGxQcm9ncmVzcy5nZXQpLFxuICAgIHNjcm9sbFNuYXBzLFxuICAgIHNjcm9sbFRhcmdldCxcbiAgICBzY3JvbGxUbyxcbiAgICBzbGlkZUxvb3BlcjogU2xpZGVMb29wZXIoYXhpcywgZGlyZWN0aW9uLCB2aWV3U2l6ZSwgY29udGVudFNpemUsIHNsaWRlU2l6ZXMsIHNsaWRlU2l6ZXNXaXRoR2Fwcywgc25hcHMsIHNjcm9sbFNuYXBzLCBvZmZzZXRMb2NhdGlvbiwgc2xpZGVzKSxcbiAgICBzbGlkZUZvY3VzLFxuICAgIHNsaWRlc0hhbmRsZXI6IFNsaWRlc0hhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIHdhdGNoU2xpZGVzKSxcbiAgICBzbGlkZXNJblZpZXcsXG4gICAgc2xpZGVJbmRleGVzLFxuICAgIHNsaWRlUmVnaXN0cnksXG4gICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgdGFyZ2V0LFxuICAgIHRyYW5zbGF0ZTogVHJhbnNsYXRlKGF4aXMsIGRpcmVjdGlvbiwgY29udGFpbmVyKVxuICB9O1xuICByZXR1cm4gZW5naW5lO1xufVxuXG5mdW5jdGlvbiBBbmltYXRpb25zKG93bmVyV2luZG93KSB7XG4gIGNvbnN0IHRpbWVTdGVwID0gMTAwMCAvIDYwO1xuICBsZXQgZW5naW5lcyA9IFtdO1xuICBsZXQgbGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gIGxldCBsYWcgPSAwO1xuICBsZXQgYW5pbWF0aW9uRnJhbWUgPSAwO1xuICBmdW5jdGlvbiBhbmltYXRlKHRpbWVTdGFtcCkge1xuICAgIGlmICghbGFzdFRpbWVTdGFtcCkgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICBjb25zdCBlbGFwc2VkID0gdGltZVN0YW1wIC0gbGFzdFRpbWVTdGFtcDtcbiAgICBsYXN0VGltZVN0YW1wID0gdGltZVN0YW1wO1xuICAgIGxhZyArPSBlbGFwc2VkO1xuICAgIHdoaWxlIChsYWcgPj0gdGltZVN0ZXApIHtcbiAgICAgIGVuZ2luZXMuZm9yRWFjaCgoe1xuICAgICAgICBhbmltYXRpb25cbiAgICAgIH0pID0+IGFuaW1hdGlvbi51cGRhdGUoKSk7XG4gICAgICBsYWcgLT0gdGltZVN0ZXA7XG4gICAgfVxuICAgIGNvbnN0IGxhZ09mZnNldCA9IG1hdGhBYnMobGFnIC8gdGltZVN0ZXApO1xuICAgIGVuZ2luZXMuZm9yRWFjaCgoe1xuICAgICAgYW5pbWF0aW9uXG4gICAgfSkgPT4gYW5pbWF0aW9uLnJlbmRlcihsYWdPZmZzZXQpKTtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIG93bmVyV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydChlbmdpbmUpIHtcbiAgICBpZiAoIWVuZ2luZXMuaW5jbHVkZXMoZW5naW5lKSkgZW5naW5lcy5wdXNoKGVuZ2luZSk7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSByZXR1cm47XG4gICAgYW5pbWF0aW9uRnJhbWUgPSBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcChlbmdpbmUpIHtcbiAgICBlbmdpbmVzID0gZW5naW5lcy5maWx0ZXIoZSA9PiBlICE9PSBlbmdpbmUpO1xuICAgIGlmIChlbmdpbmVzLmxlbmd0aCkgcmV0dXJuO1xuICAgIG93bmVyV2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lKTtcbiAgICBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgICBsYWcgPSAwO1xuICAgIGFuaW1hdGlvbkZyYW1lID0gMDtcbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBsYXN0VGltZVN0YW1wID0gbnVsbDtcbiAgICBsYWcgPSAwO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICByZXNldCxcbiAgICB3aW5kb3c6IG93bmVyV2luZG93XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IHt9O1xuICBsZXQgYXBpO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgYXBpID0gZW1ibGFBcGk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xuICAgIHJldHVybiBsaXN0ZW5lcnNbZXZ0XSB8fCBbXTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgIGdldExpc3RlbmVycyhldnQpLmZvckVhY2goZSA9PiBlKGFwaSwgZXZ0KSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgIGxpc3RlbmVyc1tldnRdID0gZ2V0TGlzdGVuZXJzKGV2dCkuY29uY2F0KFtjYl0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIG9mZihldnQsIGNiKSB7XG4gICAgbGlzdGVuZXJzW2V2dF0gPSBnZXRMaXN0ZW5lcnMoZXZ0KS5maWx0ZXIoZSA9PiBlICE9PSBjYik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGVtaXQsXG4gICAgb2ZmLFxuICAgIG9uXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWxpZ246ICdjZW50ZXInLFxuICBheGlzOiAneCcsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgc2xpZGVzOiBudWxsLFxuICBjb250YWluU2Nyb2xsOiAndHJpbVNuYXBzJyxcbiAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gIGluVmlld1RocmVzaG9sZDogMCxcbiAgYnJlYWtwb2ludHM6IHt9LFxuICBkcmFnRnJlZTogZmFsc2UsXG4gIGRyYWdUaHJlc2hvbGQ6IDEwLFxuICBsb29wOiBmYWxzZSxcbiAgc2tpcFNuYXBzOiBmYWxzZSxcbiAgZHVyYXRpb246IDI1LFxuICBzdGFydEluZGV4OiAwLFxuICBhY3RpdmU6IHRydWUsXG4gIHdhdGNoRHJhZzogdHJ1ZSxcbiAgd2F0Y2hSZXNpemU6IHRydWUsXG4gIHdhdGNoU2xpZGVzOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBPcHRpb25zSGFuZGxlcihvd25lcldpbmRvdykge1xuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uc0EsIG9wdGlvbnNCKSB7XG4gICAgcmV0dXJuIG9iamVjdHNNZXJnZURlZXAob3B0aW9uc0EsIG9wdGlvbnNCIHx8IHt9KTtcbiAgfVxuICBmdW5jdGlvbiBvcHRpb25zQXRNZWRpYShvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uc0F0TWVkaWEgPSBvcHRpb25zLmJyZWFrcG9pbnRzIHx8IHt9O1xuICAgIGNvbnN0IG1hdGNoZWRNZWRpYU9wdGlvbnMgPSBvYmplY3RLZXlzKG9wdGlvbnNBdE1lZGlhKS5maWx0ZXIobWVkaWEgPT4gb3duZXJXaW5kb3cubWF0Y2hNZWRpYShtZWRpYSkubWF0Y2hlcykubWFwKG1lZGlhID0+IG9wdGlvbnNBdE1lZGlhW21lZGlhXSkucmVkdWNlKChhLCBtZWRpYU9wdGlvbikgPT4gbWVyZ2VPcHRpb25zKGEsIG1lZGlhT3B0aW9uKSwge30pO1xuICAgIHJldHVybiBtZXJnZU9wdGlvbnMob3B0aW9ucywgbWF0Y2hlZE1lZGlhT3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gb3B0aW9uc01lZGlhUXVlcmllcyhvcHRpb25zTGlzdCkge1xuICAgIHJldHVybiBvcHRpb25zTGlzdC5tYXAob3B0aW9ucyA9PiBvYmplY3RLZXlzKG9wdGlvbnMuYnJlYWtwb2ludHMgfHwge30pKS5yZWR1Y2UoKGFjYywgbWVkaWFRdWVyaWVzKSA9PiBhY2MuY29uY2F0KG1lZGlhUXVlcmllcyksIFtdKS5tYXAob3duZXJXaW5kb3cubWF0Y2hNZWRpYSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgb3B0aW9uc0F0TWVkaWEsXG4gICAgb3B0aW9uc01lZGlhUXVlcmllc1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGx1Z2luc0hhbmRsZXIob3B0aW9uc0hhbmRsZXIpIHtcbiAgbGV0IGFjdGl2ZVBsdWdpbnMgPSBbXTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSwgcGx1Z2lucykge1xuICAgIGFjdGl2ZVBsdWdpbnMgPSBwbHVnaW5zLmZpbHRlcigoe1xuICAgICAgb3B0aW9uc1xuICAgIH0pID0+IG9wdGlvbnNIYW5kbGVyLm9wdGlvbnNBdE1lZGlhKG9wdGlvbnMpLmFjdGl2ZSAhPT0gZmFsc2UpO1xuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmluaXQoZW1ibGFBcGksIG9wdGlvbnNIYW5kbGVyKSk7XG4gICAgcmV0dXJuIHBsdWdpbnMucmVkdWNlKChtYXAsIHBsdWdpbikgPT4gT2JqZWN0LmFzc2lnbihtYXAsIHtcbiAgICAgIFtwbHVnaW4ubmFtZV06IHBsdWdpblxuICAgIH0pLCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBhY3RpdmVQbHVnaW5zID0gYWN0aXZlUGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbi5kZXN0cm95KCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFbWJsYUNhcm91c2VsKHJvb3QsIHVzZXJPcHRpb25zLCB1c2VyUGx1Z2lucykge1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gcm9vdC5vd25lckRvY3VtZW50O1xuICBjb25zdCBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNvbnN0IG9wdGlvbnNIYW5kbGVyID0gT3B0aW9uc0hhbmRsZXIob3duZXJXaW5kb3cpO1xuICBjb25zdCBwbHVnaW5zSGFuZGxlciA9IFBsdWdpbnNIYW5kbGVyKG9wdGlvbnNIYW5kbGVyKTtcbiAgY29uc3QgbWVkaWFIYW5kbGVycyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZG9jdW1lbnRWaXNpYmxlSGFuZGxlciA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZXZlbnRIYW5kbGVyID0gRXZlbnRIYW5kbGVyKCk7XG4gIGNvbnN0IHtcbiAgICBhbmltYXRpb25SZWFsbXNcbiAgfSA9IEVtYmxhQ2Fyb3VzZWw7XG4gIGNvbnN0IHtcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgb3B0aW9uc0F0TWVkaWEsXG4gICAgb3B0aW9uc01lZGlhUXVlcmllc1xuICB9ID0gb3B0aW9uc0hhbmRsZXI7XG4gIGNvbnN0IHtcbiAgICBvbixcbiAgICBvZmYsXG4gICAgZW1pdFxuICB9ID0gZXZlbnRIYW5kbGVyO1xuICBjb25zdCByZUluaXQgPSByZUFjdGl2YXRlO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGxldCBlbmdpbmU7XG4gIGxldCBvcHRpb25zQmFzZSA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgRW1ibGFDYXJvdXNlbC5nbG9iYWxPcHRpb25zKTtcbiAgbGV0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UpO1xuICBsZXQgcGx1Z2luTGlzdCA9IFtdO1xuICBsZXQgcGx1Z2luQXBpcztcbiAgbGV0IGNvbnRhaW5lcjtcbiAgbGV0IHNsaWRlcztcbiAgZnVuY3Rpb24gc3RvcmVFbGVtZW50cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHVzZXJDb250YWluZXIsXG4gICAgICBzbGlkZXM6IHVzZXJTbGlkZXNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjdXN0b21Db250YWluZXIgPSBpc1N0cmluZyh1c2VyQ29udGFpbmVyKSA/IHJvb3QucXVlcnlTZWxlY3Rvcih1c2VyQ29udGFpbmVyKSA6IHVzZXJDb250YWluZXI7XG4gICAgY29udGFpbmVyID0gY3VzdG9tQ29udGFpbmVyIHx8IHJvb3QuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgY3VzdG9tU2xpZGVzID0gaXNTdHJpbmcodXNlclNsaWRlcykgPyBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh1c2VyU2xpZGVzKSA6IHVzZXJTbGlkZXM7XG4gICAgc2xpZGVzID0gW10uc2xpY2UuY2FsbChjdXN0b21TbGlkZXMgfHwgY29udGFpbmVyLmNoaWxkcmVuKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbmdpbmUob3B0aW9ucywgYW5pbWF0aW9ucykge1xuICAgIGNvbnN0IGVuZ2luZSA9IEVuZ2luZShyb290LCBjb250YWluZXIsIHNsaWRlcywgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIG9wdGlvbnMsIGV2ZW50SGFuZGxlciwgYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMubG9vcCAmJiAhZW5naW5lLnNsaWRlTG9vcGVyLmNhbkxvb3AoKSkge1xuICAgICAgY29uc3Qgb3B0aW9uc1dpdGhvdXRMb29wID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBsb29wOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3JlYXRlRW5naW5lKG9wdGlvbnNXaXRob3V0TG9vcCwgYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cbiAgZnVuY3Rpb24gYWN0aXZhdGUod2l0aE9wdGlvbnMsIHdpdGhQbHVnaW5zKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGNvbnN0IGFuaW1hdGlvblJlYWxtID0gYW5pbWF0aW9uUmVhbG1zLmZpbmQoYSA9PiBhLndpbmRvdyA9PT0gb3duZXJXaW5kb3cpO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBhbmltYXRpb25SZWFsbSB8fCBBbmltYXRpb25zKG93bmVyV2luZG93KTtcbiAgICBpZiAoIWFuaW1hdGlvblJlYWxtKSBhbmltYXRpb25SZWFsbXMucHVzaChhbmltYXRpb25zKTtcbiAgICBvcHRpb25zQmFzZSA9IG1lcmdlT3B0aW9ucyhvcHRpb25zQmFzZSwgd2l0aE9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zQXRNZWRpYShvcHRpb25zQmFzZSk7XG4gICAgcGx1Z2luTGlzdCA9IHdpdGhQbHVnaW5zIHx8IHBsdWdpbkxpc3Q7XG4gICAgc3RvcmVFbGVtZW50cygpO1xuICAgIGVuZ2luZSA9IGNyZWF0ZUVuZ2luZShvcHRpb25zLCBhbmltYXRpb25zKTtcbiAgICBvcHRpb25zTWVkaWFRdWVyaWVzKFtvcHRpb25zQmFzZSwgLi4ucGx1Z2luTGlzdC5tYXAoKHtcbiAgICAgIG9wdGlvbnNcbiAgICB9KSA9PiBvcHRpb25zKV0pLmZvckVhY2gocXVlcnkgPT4gbWVkaWFIYW5kbGVycy5hZGQocXVlcnksICdjaGFuZ2UnLCByZUFjdGl2YXRlKSk7XG4gICAgaWYgKCFvcHRpb25zLmFjdGl2ZSkgcmV0dXJuO1xuICAgIGVuZ2luZS50cmFuc2xhdGUudG8oZW5naW5lLmxvY2F0aW9uLmdldCgpKTtcbiAgICBlbmdpbmUuc2xpZGVzSW5WaWV3LmluaXQoKTtcbiAgICBlbmdpbmUuc2xpZGVGb2N1cy5pbml0KCk7XG4gICAgZW5naW5lLmV2ZW50SGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGVuZ2luZS5yZXNpemVIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgZW5naW5lLnNsaWRlc0hhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBkb2N1bWVudFZpc2libGVIYW5kbGVyLmFkZChvd25lckRvY3VtZW50LCAndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgIGlmIChvd25lckRvY3VtZW50LmhpZGRlbikgYW5pbWF0aW9ucy5yZXNldCgpO1xuICAgIH0pO1xuICAgIGlmIChlbmdpbmUub3B0aW9ucy5sb29wKSBlbmdpbmUuc2xpZGVMb29wZXIubG9vcCgpO1xuICAgIGlmIChjb250YWluZXIub2Zmc2V0UGFyZW50ICYmIHNsaWRlcy5sZW5ndGgpIGVuZ2luZS5kcmFnSGFuZGxlci5pbml0KHNlbGYpO1xuICAgIHBsdWdpbkFwaXMgPSBwbHVnaW5zSGFuZGxlci5pbml0KHNlbGYsIHBsdWdpbkxpc3QpO1xuICB9XG4gIGZ1bmN0aW9uIHJlQWN0aXZhdGUod2l0aE9wdGlvbnMsIHdpdGhQbHVnaW5zKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICAgIGRlQWN0aXZhdGUoKTtcbiAgICBhY3RpdmF0ZShtZXJnZU9wdGlvbnMoe1xuICAgICAgc3RhcnRJbmRleFxuICAgIH0sIHdpdGhPcHRpb25zKSwgd2l0aFBsdWdpbnMpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdyZUluaXQnKTtcbiAgfVxuICBmdW5jdGlvbiBkZUFjdGl2YXRlKCkge1xuICAgIGVuZ2luZS5kcmFnSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLmFuaW1hdGlvbi5zdG9wKCk7XG4gICAgZW5naW5lLmV2ZW50U3RvcmUuY2xlYXIoKTtcbiAgICBlbmdpbmUudHJhbnNsYXRlLmNsZWFyKCk7XG4gICAgZW5naW5lLnNsaWRlTG9vcGVyLmNsZWFyKCk7XG4gICAgZW5naW5lLnJlc2l6ZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5zbGlkZXNIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuc2xpZGVzSW5WaWV3LmRlc3Ryb3koKTtcbiAgICBwbHVnaW5zSGFuZGxlci5kZXN0cm95KCk7XG4gICAgbWVkaWFIYW5kbGVycy5jbGVhcigpO1xuICAgIGRvY3VtZW50VmlzaWJsZUhhbmRsZXIuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICAgIG1lZGlhSGFuZGxlcnMuY2xlYXIoKTtcbiAgICBkZUFjdGl2YXRlKCk7XG4gICAgZXZlbnRIYW5kbGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxUbyhpbmRleCwganVtcCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFvcHRpb25zLmFjdGl2ZSB8fCBkZXN0cm95ZWQpIHJldHVybjtcbiAgICBlbmdpbmUuc2Nyb2xsQm9keS51c2VCYXNlRnJpY3Rpb24oKS51c2VEdXJhdGlvbihqdW1wID09PSB0cnVlID8gMCA6IG9wdGlvbnMuZHVyYXRpb24pO1xuICAgIGVuZ2luZS5zY3JvbGxUby5pbmRleChpbmRleCwgZGlyZWN0aW9uIHx8IDApO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbE5leHQoanVtcCkge1xuICAgIGNvbnN0IG5leHQgPSBlbmdpbmUuaW5kZXguYWRkKDEpLmdldCgpO1xuICAgIHNjcm9sbFRvKG5leHQsIGp1bXAsIC0xKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxQcmV2KGp1bXApIHtcbiAgICBjb25zdCBwcmV2ID0gZW5naW5lLmluZGV4LmFkZCgtMSkuZ2V0KCk7XG4gICAgc2Nyb2xsVG8ocHJldiwganVtcCwgMSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuU2Nyb2xsTmV4dCgpIHtcbiAgICBjb25zdCBuZXh0ID0gZW5naW5lLmluZGV4LmFkZCgxKS5nZXQoKTtcbiAgICByZXR1cm4gbmV4dCAhPT0gc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuU2Nyb2xsUHJldigpIHtcbiAgICBjb25zdCBwcmV2ID0gZW5naW5lLmluZGV4LmFkZCgtMSkuZ2V0KCk7XG4gICAgcmV0dXJuIHByZXYgIT09IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFNuYXBMaXN0KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2Nyb2xsU25hcExpc3Q7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsUHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zY3JvbGxQcm9ncmVzcy5nZXQoZW5naW5lLmxvY2F0aW9uLmdldCgpKTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RlZFNjcm9sbFNuYXAoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5pbmRleC5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2aW91c1Njcm9sbFNuYXAoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5pbmRleFByZXZpb3VzLmdldCgpO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc0luVmlldygpIHtcbiAgICByZXR1cm4gZW5naW5lLnNsaWRlc0luVmlldy5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZXNOb3RJblZpZXcoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zbGlkZXNJblZpZXcuZ2V0KGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBwbHVnaW5zKCkge1xuICAgIHJldHVybiBwbHVnaW5BcGlzO1xuICB9XG4gIGZ1bmN0aW9uIGludGVybmFsRW5naW5lKCkge1xuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cbiAgZnVuY3Rpb24gcm9vdE5vZGUoKSB7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cbiAgZnVuY3Rpb24gY29udGFpbmVyTm9kZSgpIHtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlTm9kZXMoKSB7XG4gICAgcmV0dXJuIHNsaWRlcztcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNhblNjcm9sbE5leHQsXG4gICAgY2FuU2Nyb2xsUHJldixcbiAgICBjb250YWluZXJOb2RlLFxuICAgIGludGVybmFsRW5naW5lLFxuICAgIGRlc3Ryb3ksXG4gICAgb2ZmLFxuICAgIG9uLFxuICAgIGVtaXQsXG4gICAgcGx1Z2lucyxcbiAgICBwcmV2aW91c1Njcm9sbFNuYXAsXG4gICAgcmVJbml0LFxuICAgIHJvb3ROb2RlLFxuICAgIHNjcm9sbE5leHQsXG4gICAgc2Nyb2xsUHJldixcbiAgICBzY3JvbGxQcm9ncmVzcyxcbiAgICBzY3JvbGxTbmFwTGlzdCxcbiAgICBzY3JvbGxUbyxcbiAgICBzZWxlY3RlZFNjcm9sbFNuYXAsXG4gICAgc2xpZGVOb2RlcyxcbiAgICBzbGlkZXNJblZpZXcsXG4gICAgc2xpZGVzTm90SW5WaWV3XG4gIH07XG4gIGFjdGl2YXRlKHVzZXJPcHRpb25zLCB1c2VyUGx1Z2lucyk7XG4gIHNldFRpbWVvdXQoKCkgPT4gZXZlbnRIYW5kbGVyLmVtaXQoJ2luaXQnKSwgMCk7XG4gIHJldHVybiBzZWxmO1xufVxuRW1ibGFDYXJvdXNlbC5hbmltYXRpb25SZWFsbXMgPSBbXTtcbkVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgRW1ibGFDYXJvdXNlbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJsYS1jYXJvdXNlbC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiaXNOdW1iZXIiLCJzdWJqZWN0IiwiaXNTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc09iamVjdCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIm1hdGhBYnMiLCJuIiwiTWF0aCIsImFicyIsIm1hdGhTaWduIiwic2lnbiIsImRlbHRhQWJzIiwidmFsdWVCIiwidmFsdWVBIiwiZmFjdG9yQWJzIiwiZGlmZiIsImFycmF5S2V5cyIsImFycmF5Iiwib2JqZWN0S2V5cyIsIm1hcCIsIk51bWJlciIsImFycmF5TGFzdCIsImFycmF5TGFzdEluZGV4IiwibWF4IiwibGVuZ3RoIiwiYXJyYXlJc0xhc3RJbmRleCIsImluZGV4IiwiYXJyYXlGcm9tTnVtYmVyIiwic3RhcnRBdCIsIkFycmF5IiwiZnJvbSIsIl8iLCJpIiwib2JqZWN0Iiwia2V5cyIsIm9iamVjdHNNZXJnZURlZXAiLCJvYmplY3RBIiwib2JqZWN0QiIsInJlZHVjZSIsIm1lcmdlZE9iamVjdHMiLCJjdXJyZW50T2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImFyZU9iamVjdHMiLCJpc01vdXNlRXZlbnQiLCJldnQiLCJvd25lcldpbmRvdyIsIk1vdXNlRXZlbnQiLCJBbGlnbm1lbnQiLCJhbGlnbiIsInZpZXdTaXplIiwicHJlZGVmaW5lZCIsInN0YXJ0IiwiY2VudGVyIiwiZW5kIiwibWVhc3VyZSIsInNlbGYiLCJBeGlzIiwiYXhpcyIsImRpcmVjdGlvbiIsInNjcm9sbCIsImNyb3NzIiwic3RhcnRFZGdlIiwiZ2V0U3RhcnRFZGdlIiwiZW5kRWRnZSIsImdldEVuZEVkZ2UiLCJtZWFzdXJlU2l6ZSIsIm5vZGVSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJMaW1pdCIsIm1pbiIsInJlYWNoZWRNaW4iLCJyZWFjaGVkTWF4IiwicmVhY2hlZEFueSIsImNvbnN0cmFpbiIsInJlbW92ZU9mZnNldCIsImNlaWwiLCJDb3VudGVyIiwibG9vcCIsImxvb3BFbmQiLCJjb3VudGVyIiwid2l0aGluTGltaXQiLCJnZXQiLCJzZXQiLCJhZGQiLCJjbG9uZSIsIkRpcmVjdGlvbiIsImFwcGx5IiwiRXZlbnRTdG9yZSIsImxpc3RlbmVycyIsIm5vZGUiLCJ0eXBlIiwiaGFuZGxlciIsIm9wdGlvbnMiLCJwYXNzaXZlIiwicmVtb3ZlTGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxlZ2FjeU1lZGlhUXVlcnlMaXN0IiwiYWRkTGlzdGVuZXIiLCJwdXNoIiwiY2xlYXIiLCJmaWx0ZXIiLCJyZW1vdmUiLCJEcmFnSGFuZGxlciIsInJvb3ROb2RlIiwib3duZXJEb2N1bWVudCIsInRhcmdldCIsImRyYWdUcmFja2VyIiwibG9jYXRpb24iLCJhbmltYXRpb24iLCJzY3JvbGxUbyIsInNjcm9sbEJvZHkiLCJzY3JvbGxUYXJnZXQiLCJldmVudEhhbmRsZXIiLCJwZXJjZW50T2ZWaWV3IiwiZHJhZ0ZyZWUiLCJkcmFnVGhyZXNob2xkIiwic2tpcFNuYXBzIiwiYmFzZUZyaWN0aW9uIiwid2F0Y2hEcmFnIiwiY3Jvc3NBeGlzIiwiZm9jdXNOb2RlcyIsIm5vblBhc3NpdmVFdmVudCIsImluaXRFdmVudHMiLCJkcmFnRXZlbnRzIiwiZ29Ub05leHRUaHJlc2hvbGQiLCJzbmFwRm9yY2VCb29zdCIsIm1vdXNlIiwidG91Y2giLCJmcmVlRm9yY2VCb29zdCIsImJhc2VTcGVlZCIsImlzTW92aW5nIiwic3RhcnRTY3JvbGwiLCJzdGFydENyb3NzIiwicG9pbnRlcklzRG93biIsInByZXZlbnRTY3JvbGwiLCJwcmV2ZW50Q2xpY2siLCJpc01vdXNlIiwiaW5pdCIsImVtYmxhQXBpIiwiZG93bklmQWxsb3dlZCIsImRvd24iLCJwcmV2ZW50RGVmYXVsdCIsInVuZGVmaW5lZCIsInVwIiwiY2xpY2siLCJkZXN0cm95IiwiYWRkRHJhZ0V2ZW50cyIsIm1vdmUiLCJpc0ZvY3VzTm9kZSIsIm5vZGVOYW1lIiwiaW5jbHVkZXMiLCJmb3JjZUJvb3N0IiwiYm9vc3QiLCJhbGxvd2VkRm9yY2UiLCJmb3JjZSIsInRhcmdldENoYW5nZWQiLCJuZXh0IiwiYmFzZUZvcmNlIiwiYnlEaXN0YW5jZSIsImRpc3RhbmNlIiwiYnlJbmRleCIsImlzTW91c2VFdnQiLCJidXR0b24iLCJidXR0b25zIiwicG9pbnRlckRvd24iLCJ1c2VGcmljdGlvbiIsInVzZUR1cmF0aW9uIiwicmVhZFBvaW50IiwiZW1pdCIsImxhc3RTY3JvbGwiLCJsYXN0Q3Jvc3MiLCJkaWZmU2Nyb2xsIiwiZGlmZkNyb3NzIiwiY2FuY2VsYWJsZSIsInBvaW50ZXJNb3ZlIiwiY3VycmVudExvY2F0aW9uIiwicmF3Rm9yY2UiLCJwb2ludGVyVXAiLCJmb3JjZUZhY3RvciIsInNwZWVkIiwiZnJpY3Rpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJEcmFnVHJhY2tlciIsImxvZ0ludGVydmFsIiwic3RhcnRFdmVudCIsImxhc3RFdmVudCIsInJlYWRUaW1lIiwidGltZVN0YW1wIiwiZXZ0QXhpcyIsInByb3BlcnR5IiwiY29vcmQiLCJ0b3VjaGVzIiwiZXhwaXJlZCIsImRpZmZEcmFnIiwiZGlmZlRpbWUiLCJpc0ZsaWNrIiwiTm9kZVJlY3RzIiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiUGVyY2VudE9mVmlldyIsIlJlc2l6ZUhhbmRsZXIiLCJjb250YWluZXIiLCJzbGlkZXMiLCJ3YXRjaFJlc2l6ZSIsIm5vZGVSZWN0cyIsInJlc2l6ZU9ic2VydmVyIiwiY29udGFpbmVyU2l6ZSIsInNsaWRlU2l6ZXMiLCJkZXN0cm95ZWQiLCJyZWFkU2l6ZSIsImRlZmF1bHRDYWxsYmFjayIsImVudHJpZXMiLCJlbnRyeSIsImlzQ29udGFpbmVyIiwic2xpZGVJbmRleCIsImluZGV4T2YiLCJsYXN0U2l6ZSIsIm5ld1NpemUiLCJkaWZmU2l6ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlSW5pdCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZU5vZGVzIiwiY29uY2F0Iiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJTY3JvbGxCb2R5Iiwib2Zmc2V0TG9jYXRpb24iLCJiYXNlRHVyYXRpb24iLCJib2R5VmVsb2NpdHkiLCJzY3JvbGxEaXJlY3Rpb24iLCJzY3JvbGxEdXJhdGlvbiIsInNjcm9sbEZyaWN0aW9uIiwicmF3TG9jYXRpb24iLCJyYXdMb2NhdGlvblByZXZpb3VzIiwic2VlayIsImlzSW5zdGFudCIsImRpcmVjdGlvbkRpZmYiLCJzZXR0bGVkIiwiZHVyYXRpb24iLCJ2ZWxvY2l0eSIsInVzZUJhc2VEdXJhdGlvbiIsInVzZUJhc2VGcmljdGlvbiIsIlNjcm9sbEJvdW5kcyIsImxpbWl0IiwicHVsbEJhY2tUaHJlc2hvbGQiLCJlZGdlT2Zmc2V0VG9sZXJhbmNlIiwiZnJpY3Rpb25MaW1pdCIsImRpc2FibGVkIiwic2hvdWxkQ29uc3RyYWluIiwiZWRnZSIsImRpZmZUb0VkZ2UiLCJkaWZmVG9UYXJnZXQiLCJzdWJ0cmFjdCIsInRvZ2dsZUFjdGl2ZSIsImFjdGl2ZSIsIlNjcm9sbENvbnRhaW4iLCJjb250ZW50U2l6ZSIsInNuYXBzQWxpZ25lZCIsImNvbnRhaW5TY3JvbGwiLCJwaXhlbFRvbGVyYW5jZSIsInNjcm9sbEJvdW5kcyIsInNuYXBzQm91bmRlZCIsIm1lYXN1cmVCb3VuZGVkIiwic2Nyb2xsQ29udGFpbkxpbWl0IiwiZmluZFNjcm9sbENvbnRhaW5MaW1pdCIsInNuYXBzQ29udGFpbmVkIiwibWVhc3VyZUNvbnRhaW5lZCIsInN0YXJ0U25hcCIsImVuZFNuYXAiLCJsYXN0SW5kZXhPZiIsInNuYXBBbGlnbmVkIiwiaXNGaXJzdCIsImlzTGFzdCIsInNjcm9sbEJvdW5kIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJzbGljZSIsIlNjcm9sbExpbWl0Iiwic2Nyb2xsU25hcHMiLCJTY3JvbGxMb29wZXIiLCJ2ZWN0b3JzIiwiam9pbnRTYWZldHkiLCJzaG91bGRMb29wIiwibG9vcERpc3RhbmNlIiwidiIsIlNjcm9sbFByb2dyZXNzIiwiU2Nyb2xsU25hcHMiLCJhbGlnbm1lbnQiLCJjb250YWluZXJSZWN0Iiwic2xpZGVSZWN0cyIsInNsaWRlc1RvU2Nyb2xsIiwiZ3JvdXBTbGlkZXMiLCJhbGlnbm1lbnRzIiwibWVhc3VyZVNpemVzIiwic25hcHMiLCJtZWFzdXJlVW5hbGlnbmVkIiwibWVhc3VyZUFsaWduZWQiLCJyZWN0cyIsInJlY3QiLCJzbmFwIiwiZyIsIlNsaWRlUmVnaXN0cnkiLCJjb250YWluU25hcHMiLCJzbGlkZUluZGV4ZXMiLCJzbGlkZVJlZ2lzdHJ5IiwiY3JlYXRlU2xpZGVSZWdpc3RyeSIsImdyb3VwZWRTbGlkZUluZGV4ZXMiLCJkb05vdENvbnRhaW4iLCJncm91cCIsImdyb3VwcyIsInJhbmdlIiwiU2Nyb2xsVGFyZ2V0IiwidGFyZ2V0VmVjdG9yIiwibWluRGlzdGFuY2UiLCJkaXN0YW5jZXMiLCJzb3J0IiwiYSIsImIiLCJmaW5kVGFyZ2V0U25hcCIsImFzY0RpZmZzVG9TbmFwcyIsInNjcm9sbFNuYXAiLCJkaWZmVG9TbmFwIiwic2hvcnRjdXQiLCJkMSIsImQyIiwidGFyZ2V0cyIsIm1hdGNoaW5nVGFyZ2V0cyIsInQiLCJ0YXJnZXRTbmFwRGlzdGFuY2UiLCJyZWFjaGVkQm91bmQiLCJzbmFwRGlzdGFuY2UiLCJTY3JvbGxUbyIsImluZGV4Q3VycmVudCIsImluZGV4UHJldmlvdXMiLCJkaXN0YW5jZURpZmYiLCJpbmRleERpZmYiLCJ0YXJnZXRJbmRleCIsIlNsaWRlRm9jdXMiLCJyb290IiwiZXZlbnRTdG9yZSIsImxhc3RUYWJQcmVzc1RpbWUiLCJkb2N1bWVudCIsInJlZ2lzdGVyVGFiUHJlc3MiLCJhZGRTbGlkZUZvY3VzRXZlbnQiLCJldmVudCIsImNvZGUiLCJEYXRlIiwiZ2V0VGltZSIsInNsaWRlIiwiZm9jdXMiLCJub3dUaW1lIiwic2Nyb2xsTGVmdCIsImZpbmRJbmRleCIsImNhcHR1cmUiLCJWZWN0b3IxRCIsImluaXRpYWxWYWx1ZSIsInZhbHVlIiwibm9ybWFsaXplSW5wdXQiLCJUcmFuc2xhdGUiLCJ0cmFuc2xhdGUiLCJ4IiwieSIsImNvbnRhaW5lclN0eWxlIiwic3R5bGUiLCJ0byIsInRyYW5zZm9ybSIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIlNsaWRlTG9vcGVyIiwic2xpZGVTaXplc1dpdGhHYXBzIiwicm91bmRpbmdTYWZldHkiLCJhc2NJdGVtcyIsImRlc2NJdGVtcyIsInJldmVyc2UiLCJsb29wUG9pbnRzIiwic3RhcnRQb2ludHMiLCJlbmRQb2ludHMiLCJyZW1vdmVTbGlkZVNpemVzIiwiaW5kZXhlcyIsInNsaWRlc0luR2FwIiwiZ2FwIiwicmVtYWluaW5nR2FwIiwiZmluZFNsaWRlQm91bmRzIiwiZmluZExvb3BQb2ludHMiLCJpc0VuZEVkZ2UiLCJzbGlkZUJvdW5kcyIsImluaXRpYWwiLCJhbHRlcmVkIiwiYm91bmRFZGdlIiwibG9vcFBvaW50Iiwic2xpZGVMb2NhdGlvbiIsImNhbkxvb3AiLCJldmVyeSIsIm90aGVySW5kZXhlcyIsInNoaWZ0TG9jYXRpb24iLCJTbGlkZXNIYW5kbGVyIiwid2F0Y2hTbGlkZXMiLCJtdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwibXV0YXRpb24iLCJNdXRhdGlvbk9ic2VydmVyIiwiY2hpbGRMaXN0IiwiU2xpZGVzSW5WaWV3IiwidGhyZXNob2xkIiwiaW50ZXJzZWN0aW9uRW50cnlNYXAiLCJpblZpZXdDYWNoZSIsIm5vdEluVmlld0NhY2hlIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInBhcmVudEVsZW1lbnQiLCJjcmVhdGVJblZpZXdMaXN0IiwiaW5WaWV3IiwibGlzdCIsInBhcnNlSW50IiwiaXNJbnRlcnNlY3RpbmciLCJpblZpZXdNYXRjaCIsIm5vdEluVmlld01hdGNoIiwiU2xpZGVTaXplcyIsInJlYWRFZGdlR2FwIiwid2l0aEVkZ2VHYXAiLCJzdGFydEdhcCIsIm1lYXN1cmVTdGFydEdhcCIsImVuZEdhcCIsIm1lYXN1cmVFbmRHYXAiLCJtZWFzdXJlV2l0aEdhcHMiLCJzbGlkZVJlY3QiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIlNsaWRlc1RvU2Nyb2xsIiwiZ3JvdXBCeU51bWJlciIsImJ5TnVtYmVyIiwiZ3JvdXBTaXplIiwiYnlTaXplIiwicmVjdEIiLCJyZWN0QSIsImVkZ2VBIiwiZWRnZUIiLCJnYXBBIiwiZ2FwQiIsImNodW5rU2l6ZSIsImN1cnJlbnRTaXplIiwicHJldmlvdXNTaXplIiwiRW5naW5lIiwiYW5pbWF0aW9ucyIsInNjcm9sbEF4aXMiLCJjb250ZW50RGlyZWN0aW9uIiwic3RhcnRJbmRleCIsImluVmlld1RocmVzaG9sZCIsInVwZGF0ZSIsImRyYWdIYW5kbGVyIiwicmVuZGVyIiwic2Nyb2xsTG9vcGVyIiwic2xpZGVMb29wZXIiLCJsYWdPZmZzZXQiLCJoYXNTZXR0bGVkIiwic3RvcCIsImVuZ2luZSIsInN0YXJ0TG9jYXRpb24iLCJzY3JvbGxQcm9ncmVzcyIsInNsaWRlc0luVmlldyIsInNsaWRlRm9jdXMiLCJyZXNpemVIYW5kbGVyIiwic2Nyb2xsU25hcExpc3QiLCJzbGlkZXNIYW5kbGVyIiwiQW5pbWF0aW9ucyIsInRpbWVTdGVwIiwiZW5naW5lcyIsImxhc3RUaW1lU3RhbXAiLCJsYWciLCJhbmltYXRpb25GcmFtZSIsImFuaW1hdGUiLCJlbGFwc2VkIiwiZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVzZXQiLCJ3aW5kb3ciLCJFdmVudEhhbmRsZXIiLCJhcGkiLCJnZXRMaXN0ZW5lcnMiLCJvbiIsImNiIiwib2ZmIiwiZGVmYXVsdE9wdGlvbnMiLCJicmVha3BvaW50cyIsIk9wdGlvbnNIYW5kbGVyIiwibWVyZ2VPcHRpb25zIiwib3B0aW9uc0EiLCJvcHRpb25zQiIsIm9wdGlvbnNBdE1lZGlhIiwibWF0Y2hlZE1lZGlhT3B0aW9ucyIsIm1lZGlhIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJtZWRpYU9wdGlvbiIsIm9wdGlvbnNNZWRpYVF1ZXJpZXMiLCJvcHRpb25zTGlzdCIsImFjYyIsIm1lZGlhUXVlcmllcyIsIlBsdWdpbnNIYW5kbGVyIiwib3B0aW9uc0hhbmRsZXIiLCJhY3RpdmVQbHVnaW5zIiwicGx1Z2lucyIsInBsdWdpbiIsImFzc2lnbiIsIm5hbWUiLCJFbWJsYUNhcm91c2VsIiwidXNlck9wdGlvbnMiLCJ1c2VyUGx1Z2lucyIsImRlZmF1bHRWaWV3IiwicGx1Z2luc0hhbmRsZXIiLCJtZWRpYUhhbmRsZXJzIiwiZG9jdW1lbnRWaXNpYmxlSGFuZGxlciIsImFuaW1hdGlvblJlYWxtcyIsInJlQWN0aXZhdGUiLCJvcHRpb25zQmFzZSIsImdsb2JhbE9wdGlvbnMiLCJwbHVnaW5MaXN0IiwicGx1Z2luQXBpcyIsInN0b3JlRWxlbWVudHMiLCJ1c2VyQ29udGFpbmVyIiwidXNlclNsaWRlcyIsImN1c3RvbUNvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJjaGlsZHJlbiIsImN1c3RvbVNsaWRlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjcmVhdGVFbmdpbmUiLCJvcHRpb25zV2l0aG91dExvb3AiLCJhY3RpdmF0ZSIsIndpdGhPcHRpb25zIiwid2l0aFBsdWdpbnMiLCJhbmltYXRpb25SZWFsbSIsImZpbmQiLCJxdWVyeSIsImhpZGRlbiIsIm9mZnNldFBhcmVudCIsInNlbGVjdGVkU2Nyb2xsU25hcCIsImRlQWN0aXZhdGUiLCJqdW1wIiwic2Nyb2xsTmV4dCIsInNjcm9sbFByZXYiLCJwcmV2IiwiY2FuU2Nyb2xsTmV4dCIsImNhblNjcm9sbFByZXYiLCJwcmV2aW91c1Njcm9sbFNuYXAiLCJzbGlkZXNOb3RJblZpZXciLCJpbnRlcm5hbEVuZ2luZSIsImNvbnRhaW5lck5vZGUiLCJzbGlkZU5vZGVzIiwic2V0VGltZW91dCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/embla-carousel/esm/embla-carousel.esm.js\n");

/***/ })

};
;